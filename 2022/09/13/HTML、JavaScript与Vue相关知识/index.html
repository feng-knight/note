<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/note/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/note/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/note/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/note/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/note/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/note/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/note/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="1. JS 垃圾回收机制： 内存泄漏和内存回收机制 本文中所使用到的参考链接： 链接1 链接2  内存泄漏什么是内存泄漏？  程序的运行需要内存。只要程序提出要求，操作系统或运行时（runtime）就必须提供内存。 对于不再使用到的内存没有被释放就是内存泄漏（memory leak）  垃圾回收机制1）垃圾回收  javascript中内存管理是自动执行的，不可见，我们创建变量，对象，函数…….都">
<meta property="og:type" content="article">
<meta property="og:title" content="HTML、JavaScript与Vue相关知识">
<meta property="og:url" content="https://feng-knight.github.io/note/2022/09/13/HTML%E3%80%81JavaScript%E4%B8%8EVue%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="F゛">
<meta property="og:description" content="1. JS 垃圾回收机制： 内存泄漏和内存回收机制 本文中所使用到的参考链接： 链接1 链接2  内存泄漏什么是内存泄漏？  程序的运行需要内存。只要程序提出要求，操作系统或运行时（runtime）就必须提供内存。 对于不再使用到的内存没有被释放就是内存泄漏（memory leak）  垃圾回收机制1）垃圾回收  javascript中内存管理是自动执行的，不可见，我们创建变量，对象，函数…….都">
<meta property="og:image" content="http://zhanglei_c.gitee.io/blog/imgs/1571651354702.png">
<meta property="og:image" content="http://zhanglei_c.gitee.io/blog/imgs/1571651466286.png">
<meta property="og:image" content="http://zhanglei_c.gitee.io/blog/imgs/1571651894080.png">
<meta property="og:image" content="http://zhanglei_c.gitee.io/blog/imgs/1571651975244.png">
<meta property="og:image" content="http://zhanglei_c.gitee.io/blog/imgs/1571652079278.png">
<meta property="og:image" content="http://zhanglei_c.gitee.io/blog/imgs/1571652159488.png">
<meta property="og:image" content="http://zhanglei_c.gitee.io/blog/imgs/1571652674315.png">
<meta property="og:image" content="http://zhanglei_c.gitee.io/blog/imgs/1571652726697.png">
<meta property="og:image" content="http://zhanglei_c.gitee.io/blog/imgs/1571652762816.png">
<meta property="og:image" content="http://zhanglei_c.gitee.io/blog/imgs/1571652789557.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/b7a1aef15d9ada65779c3cfe09b4f4ea.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4f8bbcec222ae9563c0a42e6251fd898.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/473477ddf1b7b03cde2f4707a45f805b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/6e7bf842a35610bed721ae4b1511de46.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/2f41e1d0221a4791082934f6bca42ef8.png">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-614ffdf64c30a06ce2628f891b0ee72b_720w.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1211722/201803/1211722-20180308153541708-1358020026.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1211722/201803/1211722-20180308153617829-2032934804.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1211722/201803/1211722-20180308153737645-1247600177.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1211722/201803/1211722-20180308153807868-61009587.png">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://common.cnblogs.com/images/copycode.gif">
<meta property="og:image" content="https://pic1.zhimg.com/v2-ac1433da3e2bd7994c96bae11692bc40_1440w.jpg?source=172ae18b">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/16799285-b2e53c6131be72ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp">
<meta property="og:image" content="https://www.w3.org/TR/css-flexbox-1/images/flex-align.svg">
<meta property="og:image" content="https://img-blog.csdn.net/20160529165707931">
<meta property="og:image" content="https://img-blog.csdn.net/20160529170816060">
<meta property="og:image" content="https://img-blog.csdn.net/20160529172314363">
<meta property="og:image" content="https://img-blog.csdn.net/20160529172339941">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201310/2013102001.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201310/2013102002.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201310/2013102003.png">
<meta property="og:image" content="https://www.ruanyifeng.com/blogimg/asset/201310/2013102004.png">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-2b6bb774a0b2125208638776184b9482_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ad50ceadc24face630fa16df2c55a337_720w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-5fc7ba6275e5f2ab5cdb3b7cb97e223d_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-739f0f7462fd7aaac444a6d2b047f696_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-55c58a901cf835e5e308e4360694505f_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-971a09fea16fff72db03d498245bc892_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/v2-bd2aa27705ca757fc676a37505a4f992_b.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-d1ca0d6b13501044a5f74c99becbcd3d_b.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-8f08aa1f5e0d5dec5b861e0c006dedc8_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-309eac4093b71a02806c3648bf34021e_720w.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-69eca8db217343dd4ecf8b1bf2c255ca_720w.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-acaa19de3de2c22c212dc208f7649bef_720w.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-963090bd3b681de3313b4466b234f4f0_b.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-a845e8e93fedead793b45e42c038e91f_720w.jpg">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1312098/201909/1312098-20190925165856499-111778537.png">
<meta property="og:image" content="https://img-blog.csdn.net/20170312191531615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDMyNjM4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170312191552052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDMyNjM4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img.php.cn/upload/article/000/000/024/54dc6dafa374e20c48269ac07ce46ceb-0.png">
<meta property="og:image" content="https://segmentfault.com/img/bVc0fdp">
<meta property="og:image" content="c:%5CUsers%5CF%E4%B8%B6%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221010140457386.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1650307/201910/1650307-20191014160745847-311614677.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1650307/201910/1650307-20191014161012932-1910070530.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1650307/201910/1650307-20191014161056659-489428628.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1650307/201910/1650307-20191014161113569-524300876.png">
<meta property="og:image" content="https://img2018.cnblogs.com/blog/1650307/201910/1650307-20191014161227305-932108410.png">
<meta property="article:published_time" content="2022-09-12T16:46:22.000Z">
<meta property="article:modified_time" content="2025-07-07T06:38:26.644Z">
<meta property="article:author" content="F゛">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zhanglei_c.gitee.io/blog/imgs/1571651354702.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/note/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://feng-knight.github.io/note/2022/09/13/HTML、JavaScript与Vue相关知识/"/>





  <title>HTML、JavaScript与Vue相关知识 | F゛</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/note/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">F゛</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">既然已经走了这么远了，不如再往前走一走.(Now that we have come so far, we might as well go a little further.)</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/note/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/note/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://feng-knight.github.io/note/note/2022/09/13/HTML%E3%80%81JavaScript%E4%B8%8EVue%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="F゛">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/note/images/dog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="F゛">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">HTML、JavaScript与Vue相关知识</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-09-13T00:46:22+08:00">
                2022-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="1-JS-垃圾回收机制："><a href="#1-JS-垃圾回收机制：" class="headerlink" title="1. JS 垃圾回收机制："></a>1. <font color="#00AFF0"><strong>JS 垃圾回收机制：</strong></font></h4><hr>
<h5 id="内存泄漏和内存回收机制"><a href="#内存泄漏和内存回收机制" class="headerlink" title="内存泄漏和内存回收机制"></a>内存泄漏和内存回收机制</h5><blockquote>
<p><strong>本文中所使用到的参考链接：</strong></p>
<p><a href="https://segmentfault.com/a/1190000018605776?utm_source=tag-newest" target="_blank" rel="noopener">链接1</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2017/04/memory-leak.html" target="_blank" rel="noopener">链接2</a></p>
</blockquote>
<h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p><strong>什么是内存泄漏？</strong></p>
<blockquote>
<p>程序的运行需要内存。只要程序提出要求，操作系统或运行时（runtime）就必须提供内存。</p>
<p>对于不再使用到的内存没有被释放就是内存泄漏（memory leak）</p>
</blockquote>
<h5 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h5><p>1）<strong>垃圾回收</strong></p>
<blockquote>
<p>javascript中内存管理是自动执行的，不可见，我们创建变量，对象，函数…….都需要分配内存，当我们的变量不再使用了，js就会发现并清理它(js垃圾收集器会按照固定的时间间隔周期性的执行这一操作）</p>
</blockquote>
<p>2） <strong>可达性</strong></p>
<blockquote>
<p>“可达性”就是指那些以某种方式能访问到的可用的值，他们被保证存储在内存中</p>
</blockquote>
<p><strong>例子</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let user &#x3D; &#123;</span><br><span class="line">    name: &quot;John&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://zhanglei_c.gitee.io/blog/imgs/1571651354702.png" target="_blank" rel="noopener"><img src="http://zhanglei_c.gitee.io/blog/imgs/1571651354702.png" alt="1571651354702"></a></p>
<p>表示全局引用了<code>user</code>,如果<code>user</code>被覆盖，则引用丢失：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user &#x3D; null</span><br></pre></td></tr></table></figure>

<p><a href="http://zhanglei_c.gitee.io/blog/imgs/1571651466286.png" target="_blank" rel="noopener"><img src="http://zhanglei_c.gitee.io/blog/imgs/1571651466286.png" alt="1571651466286"></a></p>
<p>现在john变成了不可达的状态，没有办法去访问它，则垃圾回收器会丢弃John数据并释放他所占的内存</p>
<p><strong>再来个例子</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function marry (man, woman) &#123;</span><br><span class="line">    woman.husban &#x3D; man</span><br><span class="line">    man.wife &#x3D; woman</span><br><span class="line">    return &#123;</span><br><span class="line">        father: man,</span><br><span class="line">        mother: woman</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let family &#x3D; marry(&#123; name: &quot;John&quot; &#125;,&#123; name: &quot;Ann&quot; &#125;)</span><br></pre></td></tr></table></figure>

<p>内存结构：</p>
<p><a href="http://zhanglei_c.gitee.io/blog/imgs/1571651894080.png" target="_blank" rel="noopener"><img src="http://zhanglei_c.gitee.io/blog/imgs/1571651894080.png" alt="1571651894080"></a></p>
<p>所有对象都可访问</p>
<p>现在我们删除两个引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete family.father</span><br><span class="line">delete family.mother.husband</span><br></pre></td></tr></table></figure>

<p><a href="http://zhanglei_c.gitee.io/blog/imgs/1571651975244.png" target="_blank" rel="noopener"><img src="http://zhanglei_c.gitee.io/blog/imgs/1571651975244.png" alt="1571651975244"></a></p>
<p>删除之后我们能发现 John 现在是不可访问状态，所以会被内存回收机制回收</p>
<p>垃圾回收之后：</p>
<p><a href="http://zhanglei_c.gitee.io/blog/imgs/1571652079278.png" target="_blank" rel="noopener"><img src="http://zhanglei_c.gitee.io/blog/imgs/1571652079278.png" alt="1571652079278"></a></p>
<h5 id="无法访问的数据区域"><a href="#无法访问的数据区域" class="headerlink" title="无法访问的数据区域"></a>无法访问的数据区域</h5><p>假如我们切断全局和family的连接会怎么样呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">family &#x3D; null</span><br></pre></td></tr></table></figure>

<p><a href="http://zhanglei_c.gitee.io/blog/imgs/1571652159488.png" target="_blank" rel="noopener"><img src="http://zhanglei_c.gitee.io/blog/imgs/1571652159488.png" alt="1571652159488"></a></p>
<p>此时虽然下面的区域还可以互相引用，但是全局作用域已经访问不到了，所以也会被删除，这种引用叫<strong>环引用</strong></p>
<h5 id="内部算法"><a href="#内部算法" class="headerlink" title="内部算法"></a>内部算法</h5><ol>
<li><strong>标记清除算法</strong></li>
</ol>
<blockquote>
<p>当变量进入环境，就将这个变量标记为进入环境，当变量离开环境就标记为离开环境</p>
<p><strong>步骤：</strong></p>
<ul>
<li>垃圾回收器获取根并<strong>“标记”</strong>他们</li>
<li>访问并标记所有来自他们（根）的引用</li>
<li>访问标记的对象并标记来自他们的引用。所有被访问的对象都会被标记，以便不会再访问同一个对象两次</li>
<li>删除没有被标记的对象</li>
</ul>
</blockquote>
<p>例如有如下对象结构：</p>
<p><a href="http://zhanglei_c.gitee.io/blog/imgs/1571652674315.png" target="_blank" rel="noopener"><img src="http://zhanglei_c.gitee.io/blog/imgs/1571652674315.png" alt="1571652674315"></a></p>
<p>第一步标记：</p>
<p><a href="http://zhanglei_c.gitee.io/blog/imgs/1571652726697.png" target="_blank" rel="noopener"><img src="http://zhanglei_c.gitee.io/blog/imgs/1571652726697.png" alt="1571652726697"></a></p>
<p>直到全部标记（子孙）完毕：</p>
<p><a href="http://zhanglei_c.gitee.io/blog/imgs/1571652762816.png" target="_blank" rel="noopener"><img src="http://zhanglei_c.gitee.io/blog/imgs/1571652762816.png" alt="1571652762816"></a></p>
<p>删除未被标记的对象：</p>
<p><a href="http://zhanglei_c.gitee.io/blog/imgs/1571652789557.png" target="_blank" rel="noopener"><img src="http://zhanglei_c.gitee.io/blog/imgs/1571652789557.png" alt="1571652789557"></a></p>
<p>2.<strong>引用计数算法</strong></p>
<blockquote>
<p>一种不太常见的垃圾收集策略</p>
<p><strong>原理：跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另一个变量，则该值的引用次数加1，相反如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1.当这个值的引用次数变为0时，则说明没有办法再访问这个值了。因此当垃圾回收器下次工作时会删除这些引用次数为0的值所占的内存。</strong></p>
</blockquote>
<p><strong>为啥这种垃圾回收机制不常用呢？下面来看一个案例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function problem()&#123;</span><br><span class="line">    var objectA &#x3D; new Object()</span><br><span class="line">    var objectB &#x3D; new Object()</span><br><span class="line">    </span><br><span class="line">    objectA.someOtherObject &#x3D; objectB</span><br><span class="line">    objectB.anotherObject &#x3D; objectA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，objectA 与 objectB 通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。</p>
<p><strong>标记清除：</strong>由于函数执行完毕后这两个对象均脱离了作用域，因此互相引用不是问题</p>
<p><strong>引用计数：</strong>当函数执行完毕后，objectA和objectB还将继续存在，因为他们的引用次数永远不会是0，假如这个函数被多次调用，会导致大量的内存得不到回收。</p>
<hr>
<h4 id="2-HTML-空元素："><a href="#2-HTML-空元素：" class="headerlink" title="2. HTML 空元素："></a>2. <font color="#00AFF0"><strong>HTML 空元素：</strong></font></h4><p>定义：没有<code>HTML</code>内容的元素被称为空元素，空元素是在开始标签中关闭的。</p>
<h5 id="HTML空元素："><a href="#HTML空元素：" class="headerlink" title="HTML空元素："></a>HTML空元素：</h5><ul>
<li><code>area</code>：在图片上指定一个热点区域</li>
<li><code>br</code>：换行</li>
<li><code>col</code>：表格中的列</li>
<li><code>hr</code>：表示段落级元素之间的主题转换（比如故事场景改变、一个章节主题改变等）。在 HTML 早期版本中，它是一个水平线。现在它仍能在可视化浏览器中表现为水平线，但目前被定义为语义上的，而不是表现层面上。</li>
<li><code>img</code></li>
<li><code>link</code></li>
<li><code>meta</code></li>
</ul>
<hr>
<h4 id="3-HTML-CSS-基础："><a href="#3-HTML-CSS-基础：" class="headerlink" title="3. HTML-CSS-基础："></a>3. <font color="#00AFF0"><strong>HTML-CSS-基础：</strong></font></h4><h5 id="1-对HTML语义化的理解"><a href="#1-对HTML语义化的理解" class="headerlink" title="1) 对HTML语义化的理解"></a>1) 对HTML语义化的理解</h5><ul>
<li>HTML语义化就是让页面内容结构化，便于浏览器、搜索引擎解析</li>
<li>在没有css样式的时候也是一种文档格式，便于阅读</li>
<li>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于SEO</li>
<li>使阅读源码的人对网站有一个更加清晰的分块，便于阅读理解</li>
</ul>
<h5 id="2-子元素垂直水平居中的实现方式"><a href="#2-子元素垂直水平居中的实现方式" class="headerlink" title="2) 子元素垂直水平居中的实现方式"></a>2) 子元素垂直水平居中的实现方式</h5><ul>
<li><p>子元素宽高不知道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;box1&quot;&gt;</span><br><span class="line">    &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;************方案一*****************&#x2F;</span><br><span class="line">.box1 &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box1 div &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    &#x2F;*transform:translate(x,y)括号的百分比数据，会以本身的长宽做参考*&#x2F;</span><br><span class="line">    transform: translate(-50%,-50%);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;************方案二*****************&#x2F;</span><br><span class="line">.box1 &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box1 div &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;************方案三*****************&#x2F;</span><br><span class="line">.box1 &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;************方案四*****************&#x2F;</span><br><span class="line">.box1 &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.box1 div &#123;</span><br><span class="line">    display: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子元素宽高知道(上述方案同样适用)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;box1&quot;&gt;</span><br><span class="line">    &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;************方案一*****************&#x2F;</span><br><span class="line">.box1 &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box1 div &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-top: -50px;&#x2F;*负的高度的一半*&#x2F;</span><br><span class="line">    margin-left: -50px;&#x2F;*负的宽度的一半*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3-css选择器-gt-空格-的区别"><a href="#3-css选择器-gt-空格-的区别" class="headerlink" title="3) css选择器 . # &gt; 空格 , + 的区别"></a>3) css选择器 <code>.</code> <code>#</code> <code>&gt;</code> <code>空格</code> <code>,</code> <code>+</code> 的区别</h5><ul>
<li><p>class选择器<code>.</code> 和 id选择器 <code>#</code></p>
<blockquote>
<p>相同的class选择器在html中可以出现多次，但是id选择器只能出现一次</p>
</blockquote>
</li>
<li><p>空格选择器</p>
<blockquote>
<p>空格选择器是后代选择器 ，包括儿子，孙子，…,只要是后代都会被选中</p>
</blockquote>
</li>
<li><p><code>&gt;</code> 子代选择器</p>
<blockquote>
<p>只能选择它的儿子</p>
</blockquote>
</li>
<li><p>兄弟选择器<code>+</code></p>
<blockquote>
<p><code>+</code>是离自己最近的兄弟选择器，只能选择自己下一个兄弟标签</p>
</blockquote>
</li>
<li><p>多个选择器<code>,</code></p>
<blockquote>
<p><code>,</code>是多个选择器，他们可以共用同一个样式</p>
</blockquote>
</li>
</ul>
<h5 id="4-BFC（块格式化上下文-Block-Formatting-Context-）"><a href="#4-BFC（块格式化上下文-Block-Formatting-Context-）" class="headerlink" title="4) BFC（块格式化上下文 Block Formatting Context ）"></a>4) BFC（块格式化上下文 Block Formatting Context ）</h5><blockquote>
<p>不要试图去解释BFC的定义，我们只需要知道它的特性就好了，BFC只有特性，“没有定义”</p>
<blockquote>
<p>特性：</p>
<ul>
<li>使BFC内部元素不会到处乱跑(浮动元素会脱离文档流，为了让他不脱离文档流就要产生BFC)</li>
<li>和浮动元素产生边界</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li><p>MDN 官方解释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。</span><br><span class="line">一个块格式化上下文由以下之一创建：</span><br><span class="line"></span><br><span class="line">根元素或其它包含它的元素</span><br><span class="line">	浮动元素 (元素的 float 不是 none)</span><br><span class="line">	绝对定位元素 (元素具有 position 为 absolute 或 fixed)</span><br><span class="line">	内联块 (元素具有 display: inline-block)</span><br><span class="line">	表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性)</span><br><span class="line">	表格标题 (元素具有 display: table-caption, HTML表格标题默认属性)</span><br><span class="line">	具有overflow 且值不是 visible 的块元素，</span><br><span class="line">	display: flow-root</span><br><span class="line">	column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包	裹在一个多列容器中。</span><br><span class="line">    一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。</span><br><span class="line">    块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="5-对H5的理解"><a href="#5-对H5的理解" class="headerlink" title="5) 对H5的理解"></a>5) 对H5的理解</h5><ul>
<li>优点<ul>
<li>多设备，跨平台</li>
<li>标签语义化，可读性高</li>
<li>提供了更多的多媒体元素（视频和音频）</li>
<li>很好的替代了Flash 和 [Microsoft Silverlight](<a href="https://baike.baidu.com/item/Microsoft" target="_blank" rel="noopener">https://baike.baidu.com/item/Microsoft</a> SilverLight/3466480?fromtitle=silverlight&amp;fromid=4088479&amp;fr=aladdin)</li>
<li>涉及到网站抓取和索引的时候，更利于SEO</li>
<li>可被大量应用于移动应用程序和游戏</li>
<li>可移植性好</li>
</ul>
</li>
<li>缺点<ul>
<li>安全性差，web storage 和 web socket很容易被黑客利用</li>
<li>兼容性差</li>
<li>未被大多数浏览器很好的支持，用户体验不佳</li>
</ul>
</li>
</ul>
<h5 id="6-CSS3动画"><a href="#6-CSS3动画" class="headerlink" title="6) CSS3动画"></a>6) CSS3动画</h5><ul>
<li><p>过渡动画 <code>transition</code></p>
<ul>
<li>从初始状态到结束状态这个过程所产生的的动画。所谓状态就是指大小，位置，颜色，变形（transform）等属性。css 过渡只能定义首尾两个状态。</li>
</ul>
</li>
<li><p>关键帧动画 <code>keyframes</code></p>
<ul>
<li><p>不同于第一种过渡动画只能定义首尾两个状态，关键帧动画可以定义多个状态，所以可以实现很多复杂的动画效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">	width:100px;</span><br><span class="line">	height:100px;</span><br><span class="line">	background:red;</span><br><span class="line">	position:relative;</span><br><span class="line">	animation:mymove 5s infinite;</span><br><span class="line">	-webkit-animation:mymove 5s infinite; &#x2F;* Safari and Chrome *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes mymove</span><br><span class="line">&#123;</span><br><span class="line">	0%   &#123;top:0px; left:0px; background:red;&#125;</span><br><span class="line">	25%  &#123;top:0px; left:100px; background:blue;&#125;</span><br><span class="line">	50%  &#123;top:100px; left:100px; background:yellow;&#125;</span><br><span class="line">	75%  &#123;top:100px; left:0px; background:green;&#125;</span><br><span class="line">	100% &#123;top:0px; left:0px; background:red;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="7-css-引入方式优先级"><a href="#7-css-引入方式优先级" class="headerlink" title="7) css 引入方式优先级"></a>7) css 引入方式优先级</h5><blockquote>
<p>行内 &gt; 内嵌 &gt; 链接 &gt; 导入</p>
</blockquote>
<h5 id="8-rem-和-px"><a href="#8-rem-和-px" class="headerlink" title="8) rem 和 px"></a>8) <code>rem</code> 和 <code>px</code></h5><ul>
<li><p>rem</p>
<blockquote>
<p>rem 是 css3 新增的一个相对长度单位，他只想对于根目录（html元素）,一般用来做手机端的适配</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; html &#123;</span><br><span class="line">&gt;     font-size: 20px; &#x2F;* 1rem &#x3D; 20px *&#x2F;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; html &#123;</span><br><span class="line">&gt;     font-size: 30px; &#x2F;* 1rem &#x3D; 30px *&#x2F;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>px</p>
<blockquote>
<p>像素，固定大小单元，一个像素等于屏幕上的一个点（当前屏幕的最小分割）。PC 端默认字体大小为16px</p>
</blockquote>
</li>
</ul>
<h5 id="9-link-和-import的区别"><a href="#9-link-和-import的区别" class="headerlink" title="9)link 和 @import的区别"></a>9)<code>link</code> 和 <code>@import</code>的区别</h5><ul>
<li><p>从属关系区别</p>
<blockquote>
<p><code>@import</code>是css提供的语法规则，只有导入样式表的作用; <code>link</code>是HTML提供的标签，不仅可以加载css文件，还可以定义<code>rel(rel 属性规定当前文档与被链接文档之间的关系。)</code>链接属性等</p>
<blockquote>
<p><code>rel</code>属性值一览</p>
</blockquote>
<p>| alternate | 文档的替代版本（比如打印页、翻译或镜像）。 |<br>| ———- | —————————————— |<br>| stylesheet | 文档的外部样式表。 |<br>| start | 集合中的第一个文档。 |<br>| next | 集合中的下一个文档。 |<br>| prev | 集合中的上一个文档。 |<br>| contents | 文档的目录。 |<br>| index | 文档的索引。 |<br>| glossary | 在文档中使用的词汇的术语表（解释）。 |<br>| copyright | 包含版权信息的文档。 |<br>| chapter | 文档的章。 |<br>| section | 文档的节。 |<br>| subsection | 文档的小节。 |<br>| appendix | 文档的附录。 |<br>| help | 帮助文档。 |<br>| bookmark | 相关文档。 |</p>
</blockquote>
</li>
<li><p>加载顺序区别</p>
<blockquote>
<p>加载页面时，<code>link</code>标签引入的 css 同时被加载；<code>@import</code>引入的css将在页面加载完毕后被加载</p>
</blockquote>
</li>
<li><p>兼容性区别</p>
<blockquote>
<p><code>@import</code>是css2.1以后才有的语法，所以只有IE5+以上的浏览器才能被识别；<code>link</code>标签作为html元素，不存在兼容性问题</p>
</blockquote>
</li>
<li><p>DOM可控性区别</p>
<blockquote>
<p><code>link</code>支持JavaScript控制DOM去改变样式；<code>@import</code>不支持</p>
</blockquote>
</li>
</ul>
<h5 id="10-CSS-Reset-的作用和用途"><a href="#10-CSS-Reset-的作用和用途" class="headerlink" title="10) CSS Reset 的作用和用途"></a>10) CSS Reset 的作用和用途</h5><blockquote>
<p>每个浏览器都会有一些自带的或者公有的默认样式，会造成布局上的一些困扰，css reset 的作用就是消除这些默认样式，使样式表现一致；也为了页面能实现跨浏览器的兼容性，所以有时候需要引入一些css重置文件去覆盖浏览器默认的样式</p>
</blockquote>
<h5 id="11-CSS-Sprites-如何使用和他的优点是什么"><a href="#11-CSS-Sprites-如何使用和他的优点是什么" class="headerlink" title="11) CSS Sprites 如何使用和他的优点是什么"></a>11) CSS Sprites 如何使用和他的优点是什么</h5><ul>
<li>css sprites(css 精灵) 就是把一堆小图片整合到一张大图片上，从而减轻服务器对图片的请求数量</li>
<li>优点<ul>
<li>减少了图片数量，减少了http请求数，减小了服务器负担</li>
<li>整个图片变小了，图片下载速度更快</li>
<li>不使用JavaScript代码，纯CSS 就可以</li>
</ul>
</li>
</ul>
<h5 id="12-为何要使用translate-而不是position-absolute，理由是什么"><a href="#12-为何要使用translate-而不是position-absolute，理由是什么" class="headerlink" title="12) 为何要使用translate()而不是position:absolute，理由是什么"></a>12) 为何要使用<code>translate()</code>而不是<code>position:absolute</code>，理由是什么</h5><blockquote>
<p>两者都是相对于自身进行移动</p>
</blockquote>
<ul>
<li>当元素原来已经有 <code>position:absolute</code> 时，此时你想要相对于自身移动，可以使用<code>translate</code></li>
<li><code>translate</code>更适合动画，因为不会引起重绘和重排</li>
<li><code>translate</code>可以调用系统自身的GPU加速，提高浏览器性能，但是过多的触发会严重导致性能问题，增加了内存使用（移动端不建议使用3D translate3d加速,会导致移动端电池寿命减少）</li>
</ul>
<blockquote>
<p>所以<code>translate</code>更适合动画，<code>position</code>一般用来布局</p>
</blockquote>
<h5 id="13-CSS处理背景透明度，文字透明与否"><a href="#13-CSS处理背景透明度，文字透明与否" class="headerlink" title="13)  CSS处理背景透明度，文字透明与否"></a>13)  CSS处理背景透明度，文字透明与否</h5><ul>
<li>背景与文字都透明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opcity: .5</span><br></pre></td></tr></table></figure>

<ul>
<li>背景透明，文字不透明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: rgba(0,0,0,0.5)</span><br></pre></td></tr></table></figure>

<h5 id="14-什么是置换元素"><a href="#14-什么是置换元素" class="headerlink" title="14) 什么是置换元素"></a>14) 什么是置换元素</h5><blockquote>
<p>置换元素的意思是 展现不是由CSS来控制的元素。这些外部元素的展现不依赖于CSS规范</p>
<p>置换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容。<br>例如：浏览器会根据<code>标签的src属性的 值来读取图片信息并显示出来，而如果查看html代码，则看不到图片的实际内容；</code>标签的type属性来决定是显示输入 框，还是单选按钮等。 html中 的<code>、</code>、<code>、</code>、`` 都是置换元素。这些元素往往没有实际的内容，即是一个空元素。</p>
<p>置换元素在其显示中生成了框，这也就是有的内联元素能够设置宽高的原因。</p>
</blockquote>
<hr>
<h4 id="4-浅拷贝与深拷贝（一）："><a href="#4-浅拷贝与深拷贝（一）：" class="headerlink" title="4. 浅拷贝与深拷贝（一）："></a>4. <font color="#00AFF0"><strong>浅拷贝与深拷贝（一）：</strong></font></h4><p>前言</p>
<p>在 javascript 中有不同的方法来复制对象，如果你还不熟悉这门语言的话，复制对象时就会很容易掉进陷阱里，那么我们怎样才能正确地复制一个对象呢？</p>
<p>读完本文，希望你能明白：</p>
<ul>
<li>什么是深/浅拷贝，他们跟赋值有何区别？</li>
<li>深/浅拷贝的实现方式有几种？</li>
</ul>
<h5 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h5><ul>
<li>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以<strong>如果其中一个对象改变了这个地址，就会影响到另一个对象</strong>。</li>
<li>深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且<strong>修改新对象不会影响原对象</strong>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a1 &#x3D; &#123;b: &#123;c: &#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">var a2 &#x3D; shallowClone(a1); &#x2F;&#x2F; 浅拷贝方法</span><br><span class="line">a2.b.c &#x3D;&#x3D;&#x3D; a1.b.c &#x2F;&#x2F; true 新旧对象还是共享同一块内存</span><br><span class="line"></span><br><span class="line">var a3 &#x3D; deepClone(a3); &#x2F;&#x2F; 深拷贝方法</span><br><span class="line">a3.b.c &#x3D;&#x3D;&#x3D; a1.b.c &#x2F;&#x2F; false 新对象跟原对象不共享内存</span><br></pre></td></tr></table></figure>

<p>借助<a href="https://github.com/ConardLi" target="_blank" rel="noopener">ConardLi大佬</a>以下两张图片，帮我们更好的理解两者的含义：<br><img src="https://img-blog.csdnimg.cn/img_convert/b7a1aef15d9ada65779c3cfe09b4f4ea.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4f8bbcec222ae9563c0a42e6251fd898.png" alt="img"></p>
<p>总而言之，浅拷贝只复制指向某个对象的指针，而不复制对象本身，<strong>新旧对象还是共享同一块内存</strong>。但深拷贝会另外创造一个一模一样的对象，<strong>新对象跟原对象不共享内存</strong>，修改新对象不会改到原对象。</p>
<h5 id="赋值和深-浅拷贝的区别"><a href="#赋值和深-浅拷贝的区别" class="headerlink" title="赋值和深/浅拷贝的区别"></a>赋值和深/浅拷贝的区别</h5><p>这三者的区别如下，不过比较的前提都是<strong>针对引用类型</strong>：</p>
<ul>
<li>当我们把一个对象赋值给一个新的变量时，<strong>赋的其实是该对象的在栈中的地址，而不是堆中的数据</strong>。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li>
<li>浅拷贝：重新在堆中创建内存，拷贝前后对象的基本数据类型互不影响，但拷贝前后对象的引用类型因共享同一块内存，会相互影响。</li>
<li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。</li>
</ul>
<p>我们先来看下面的例子，对比赋值与深/浅拷贝得到的对象修改后对原始对象的影响：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象赋值</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">'浪里行舟'</span>,</span><br><span class="line">    arr : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line">obj2.name = <span class="string">"阿浪"</span>;</span><br><span class="line">obj2.arr[<span class="number">1</span>] =[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj1'</span>,obj1) <span class="comment">// obj1 &#123; name: '阿浪', arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj2'</span>,obj2) <span class="comment">// obj2 &#123; name: '阿浪', arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">'浪里行舟'</span>,</span><br><span class="line">    arr : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj3=shallowClone(obj1)</span><br><span class="line">obj3.name = <span class="string">"阿浪"</span>;</span><br><span class="line">obj3.arr[<span class="number">1</span>] = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ; <span class="comment">// 新旧对象还是共享同一块内存</span></span><br><span class="line"><span class="comment">// 这是个浅拷贝的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.hasOwnProperty(i)) &#123;</span><br><span class="line">            target[i] = source[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj1'</span>,obj1) <span class="comment">// obj1 &#123; name: '浪里行舟', arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj3'</span>,obj3) <span class="comment">// obj3 &#123; name: '阿浪', arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name : <span class="string">'浪里行舟'</span>,</span><br><span class="line">    arr : [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj4=deepClone(obj1)</span><br><span class="line">obj4.name = <span class="string">"阿浪"</span>;</span><br><span class="line">obj4.arr[<span class="number">1</span>] = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ; <span class="comment">// 新对象跟原对象不共享内存</span></span><br><span class="line"><span class="comment">// 这是个深拷贝的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj; </span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="comment">// 实现一个递归拷贝</span></span><br><span class="line">        cloneObj[key] = deepClone(obj[key]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj1'</span>,obj1) <span class="comment">// obj1 &#123; name: '浪里行舟', arr: [ 1, [ 2, 3 ], 4 ] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj4'</span>,obj4) <span class="comment">// obj4 &#123; name: '阿浪', arr: [ 1, [ 5, 6, 7 ], 4 ] &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，obj1是原始对象，obj2是赋值操作得到的对象，obj3浅拷贝得到的对象，obj4深拷贝得到的对象，通过下面的表格，我们可以很清晰看到他们对原始数据的影响：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/473477ddf1b7b03cde2f4707a45f805b.png" alt="img"></p>
<h5 id="浅拷贝的实现方式"><a href="#浅拷贝的实现方式" class="headerlink" title="浅拷贝的实现方式"></a>浅拷贝的实现方式</h5><h6 id="1-Object-assign"><a href="#1-Object-assign" class="headerlink" title="1) Object.assign()"></a>1) Object.assign()</h6><p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">person</span>: &#123;<span class="attr">name</span>: <span class="string">"kobe"</span>, <span class="attr">age</span>: <span class="number">41</span>&#125;,<span class="attr">sports</span>:<span class="string">'basketball'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">obj2.person.name = <span class="string">"wade"</span>;</span><br><span class="line">obj2.sports = <span class="string">'football'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123; person: &#123; name: 'wade', age: 41 &#125;, sports: 'basketball' &#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="2-函数库lodash的-clone方法"><a href="#2-函数库lodash的-clone方法" class="headerlink" title="2) 函数库lodash的_.clone方法"></a>2) 函数库lodash的_.clone方法</h6><p>该函数库也有提供_.clone用来做 Shallow Copy,后面我们会再介绍利用这个库实现深拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    c: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = _.clone(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.b.f === obj2.b.f);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h6 id="3-展开运算符…"><a href="#3-展开运算符…" class="headerlink" title="3) 展开运算符…"></a>3) 展开运算符…</h6><p>展开运算符是一个 es6 / es2015特性，它提供了一种非常方便的方式来执行浅拷贝，这与 Object.assign ()的功能相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">'Kobe'</span>, <span class="attr">address</span>:&#123;<span class="attr">x</span>:<span class="number">100</span>,<span class="attr">y</span>:<span class="number">100</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> obj2= &#123;... obj1&#125;</span><br><span class="line">obj1.address.x = <span class="number">200</span>;</span><br><span class="line">obj1.name = <span class="string">'wade'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj2'</span>,obj2) <span class="comment">// obj2 &#123; name: 'Kobe', address: &#123; x: 200, y: 100 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<h6 id="4-Array-prototype-concat"><a href="#4-Array-prototype-concat" class="headerlink" title="4) Array.prototype.concat()"></a>4) Array.prototype.concat()</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">    username: <span class="string">'kobe'</span></span><br><span class="line">    &#125;];</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.concat();    </span><br><span class="line">arr2[<span class="number">2</span>].username = <span class="string">'wade'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//[ 1, 3, &#123; username: 'wade' &#125; ]</span></span><br></pre></td></tr></table></figure>

<h6 id="5-Array-prototype-slice"><a href="#5-Array-prototype-slice" class="headerlink" title="5) Array.prototype.slice()"></a>5) Array.prototype.slice()</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">    username: <span class="string">' kobe'</span></span><br><span class="line">    &#125;];</span><br><span class="line"><span class="keyword">let</span> arr3 = arr.slice();</span><br><span class="line">arr3[<span class="number">2</span>].username = <span class="string">'wade'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [ 1, 3, &#123; username: 'wade' &#125; ]</span></span><br></pre></td></tr></table></figure>

<h5 id="深拷贝的实现方式"><a href="#深拷贝的实现方式" class="headerlink" title="深拷贝的实现方式"></a>深拷贝的实现方式</h5><h6 id="1-JSON-parse-JSON-stringify"><a href="#1-JSON-parse-JSON-stringify" class="headerlink" title="1) JSON.parse(JSON.stringify())"></a>1) JSON.parse(JSON.stringify())</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">    username: <span class="string">' kobe'</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">arr4[<span class="number">2</span>].username = <span class="string">'duncan'</span>; </span><br><span class="line"><span class="built_in">console</span>.log(arr, arr4)</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/6e7bf842a35610bed721ae4b1511de46.png" alt="img"></p>
<p>这也是利用JSON.stringify将对象转成JSON字符串，再用JSON.parse把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p>
<p><strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数和正则</strong>，因为这两者基于JSON.stringify和JSON.parse处理后，得到的正则就不再是正则（变为空对象），得到的函数就不再是函数（变为null）了。</p>
<p>比如下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, &#123;</span><br><span class="line">    username: <span class="string">' kobe'</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;];</span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">arr4[<span class="number">2</span>].username = <span class="string">'duncan'</span>; </span><br><span class="line"><span class="built_in">console</span>.log(arr, arr4)</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/2f41e1d0221a4791082934f6bca42ef8.png" alt="img"></p>
<h6 id="2-函数库lodash的-cloneDeep方法"><a href="#2-函数库lodash的-cloneDeep方法" class="headerlink" title="2) 函数库lodash的_.cloneDeep方法"></a>2) 函数库lodash的_.cloneDeep方法</h6><p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    c: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = _.cloneDeep(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.b.f === obj2.b.f);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h6 id="3-jQuery-extend-方法"><a href="#3-jQuery-extend-方法" class="headerlink" title="3) jQuery.extend()方法"></a>3) jQuery.extend()方法</h6><p>jquery 有提供一個<code>$.extend</code>可以用来做 Deep Copy</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.extend(deepCopy, target, object1, [objectN])<span class="comment">//第一个参数为true,就是深拷贝</span></span><br><span class="line"><span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    c: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = $.extend(<span class="literal">true</span>, &#123;&#125;, obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.b.f === obj2.b.f); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h6 id="4-手写递归方法"><a href="#4-手写递归方法" class="headerlink" title="4) 手写递归方法"></a>4) 手写递归方法</h6><p>递归方法实现深度克隆原理：<strong>遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</strong>。</p>
<p>有种特殊情况需注意就是对象存在<strong>循环引用</strong>的情况，即对象的属性直接的引用了自身的情况，解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。关于这块如有疑惑，请仔细阅读<code>ConardLi大佬</code><a href="https://segmentfault.com/a/1190000020255831" target="_blank" rel="noopener">如何写出一个惊艳面试官的深拷贝?</a>这篇文章。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, hash = new WeakMap(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span>) <span class="keyword">return</span> obj; <span class="comment">// 如果是null或者undefined我就不进行拷贝操作</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj);</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj);</span><br><span class="line">  <span class="comment">// 可能是对象或者普通的值  如果是函数的话是不需要深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">"object"</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="comment">// 是对象的话就要进行深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (hash.get(obj)) <span class="keyword">return</span> hash.get(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = <span class="keyword">new</span> obj.constructor();</span><br><span class="line">  <span class="comment">// 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身</span></span><br><span class="line">  hash.set(obj, cloneObj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 实现一个递归拷贝</span></span><br><span class="line">      cloneObj[key] = deepClone(obj[key], hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="number">1</span>, <span class="attr">address</span>: &#123; <span class="attr">x</span>: <span class="number">100</span> &#125; &#125;;</span><br><span class="line">obj.o = obj; <span class="comment">// 对象存在循环引用的情况</span></span><br><span class="line"><span class="keyword">let</span> d = deepClone(obj);</span><br><span class="line">obj.address.x = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br></pre></td></tr></table></figure>

<p><font color="red">注：</font>转载于：<a href="https://github.com/ljianshu/Blog/issues/5" target="_blank" rel="noopener">https://github.com/ljianshu/Blog/issues/5</a></p>
<hr>
<h4 id="5-浅拷贝与深拷贝（二）："><a href="#5-浅拷贝与深拷贝（二）：" class="headerlink" title="5. 浅拷贝与深拷贝（二）："></a>5. <font color="#00AFF0"><strong>浅拷贝与深拷贝（二）：</strong></font></h4><p>在 JavaScript 中有两中变量类型数据, 基本类型和引用类型. 对值类型的复制操作会对变量值进行拷贝, 两者互不相干. 而引用类型只会对存储变量的指针地址进行拷贝, 导致两个变量指向同一个地址, 也就是同一份数据, 修改其中一个会直接影响另外一个.</p>
<p>而我们要谈的浅拷贝与深拷贝就是专指引用类型.</p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>浅拷贝是最简单易理解的, 只对引用类型进行一级拷贝.</p>
<ul>
<li><strong>自行实现</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function shallowClone(source) &#123;</span><br><span class="line">    var target &#x3D; &#123;&#125;;</span><br><span class="line">    for(var i in source) &#123;</span><br><span class="line">        if (source.hasOwnProperty(i)) &#123;</span><br><span class="line">            target[i] &#x3D; source[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Object.assign</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">&#125;;</span><br><span class="line">let objCopy &#x3D; Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(objCopy);</span><br><span class="line">&#x2F;&#x2F; Result - &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码会将所有的可枚举的自身属性复制到目标对象.</p>
<ul>
<li><strong>扩展操作符 (…)</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var sourceObject &#x3D; &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: function() &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var targetObject &#x3D; &#123; ...sourceObject &#125;;</span><br><span class="line">console.log(targetObject.b &#x3D;&#x3D;&#x3D; sourceObject.b); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>浅拷贝只会对一级进行拷贝, 对于嵌套的引用类型依然是同一个指针地址.</p>
<h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>深拷贝会对任意的嵌套层级进行拷贝, 保证所有的引用类型全部是新对象, 不会和原对象有任何的关系, 彼此的修改不会互相影响.</p>
<ol>
<li><strong>奇淫巧技 JSON.parse(JSON.stringify(object))</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123; </span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123; </span><br><span class="line">    c: 2,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let newObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line"></span><br><span class="line">obj.b.c &#x3D; 20;</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123; a: 1, b: &#123; c: 20 &#125; &#125;</span><br><span class="line">console.log(newObj); &#x2F;&#x2F; &#123; a: 1, b: &#123; c: 2 &#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法虽然简单但是有很多的问题.</p>
<p><strong>第一个: 不能拷贝函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  name: &#39;neo&#39;,</span><br><span class="line">  sayName: function exec() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">let method &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(method); &#x2F;&#x2F; JSON.parse(JSON.stringify(obj))</span><br><span class="line">&#x2F;*</span><br><span class="line">&#123;</span><br><span class="line">  name: &quot;neo&quot;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>第二个: 循环引用</strong></p>
<p>循环引用是说对象的对象引用了他们自身. 这个是深拷贝中一个老生常谈的问题.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 循环引用</span><br><span class="line">let obj &#x3D; &#123; </span><br><span class="line">  a: &#39;a&#39;,</span><br><span class="line">  b: &#123; </span><br><span class="line">    c: &#39;c&#39;,</span><br><span class="line">    d: &#39;d&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj.c &#x3D; obj.b;</span><br><span class="line">obj.e &#x3D; obj.a;</span><br><span class="line">obj.b.c &#x3D; obj.c;</span><br><span class="line">obj.b.d &#x3D; obj.b;</span><br><span class="line">obj.b.e &#x3D; obj.b.c;</span><br><span class="line">let newObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(newObj);</span><br></pre></td></tr></table></figure>

<p>上面代码执行的结果是:</p>
<p><img src="https://pic4.zhimg.com/80/v2-614ffdf64c30a06ce2628f891b0ee72b_720w.png" alt="img"></p>
<p>所以说, JSON.parse(JSON.stringify(obj)) 没办法解决循环引用的问题.</p>
<p><strong>第三个: 值为 undefined 的属性会被忽略</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    a: &#39;lendel&#39;,</span><br><span class="line">    b: undefined</span><br><span class="line">&#125;;</span><br><span class="line">var newObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(newObj);</span><br><span class="line">&#x2F;&#x2F; 结果</span><br><span class="line">&#x2F;*</span><br><span class="line">  &#123; a: &#39;lendel&#39; &#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>



<p><strong>第四个: Infinity 值会被置为 null</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    a: &#39;lendel&#39;,</span><br><span class="line">    i: Infinity</span><br><span class="line">&#125;;</span><br><span class="line">var newObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(newObj);</span><br><span class="line">&#x2F;&#x2F; 结果</span><br><span class="line">&#x2F;*</span><br><span class="line">  &#123; a: &#39;lendel&#39;, i: null &#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>



<p><strong>第五个: 一些对象会被转为字符串</strong></p>
<p>这种方法会将一些类型的对象转变字符串, 例如 Date, Set, Map……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    a: &#39;lendel&#39;,</span><br><span class="line">    d: new Date()</span><br><span class="line">&#125;;</span><br><span class="line">var newObj &#x3D; JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(newObj);</span><br><span class="line">&#x2F;&#x2F; 结果</span><br><span class="line">&#x2F;*</span><br><span class="line">&#123; a: &#39;lendel&#39;, d: &#39;2019-04-01T02:53:37.720Z&#39; &#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<h5 id="一个简单的深拷贝方法"><a href="#一个简单的深拷贝方法" class="headerlink" title="一个简单的深拷贝方法"></a><strong>一个简单的深拷贝方法</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function cloneObject(obj) &#123;</span><br><span class="line">    var clone &#x3D; &#123;&#125;;</span><br><span class="line">    for(var i in obj) &#123;</span><br><span class="line">        if(obj[i] !&#x3D; null &amp;&amp;  typeof(obj[i])&#x3D;&#x3D;&quot;object&quot;)</span><br><span class="line">            clone[i] &#x3D; cloneObject(obj[i]);</span><br><span class="line">        else</span><br><span class="line">            clone[i] &#x3D; obj[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一段非常简单的深拷贝函数, 因为简单,所以问题也多. 参数的校验并不完备, 利用递归时当层次过深的时候容易造成栈溢出, 还有循环引用.</p>
<p>上面的代码体现了深拷贝的基本思想，但实际使用中建议使用 lodash 等现成的库</p>
<p>对于栈溢出的问题, 我们可以将递归改用循环来解决:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function loopClone(x) &#123;</span><br><span class="line">    const root &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 栈</span><br><span class="line">    const loopList &#x3D; [</span><br><span class="line">        &#123;</span><br><span class="line">            parent: root,</span><br><span class="line">            key: undefined,</span><br><span class="line">            data: x</span><br><span class="line">        &#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while (loopList.length) &#123;</span><br><span class="line">        &#x2F;&#x2F; 深度优先</span><br><span class="line">        const node &#x3D; loopList.pop();</span><br><span class="line">        const parent &#x3D; node.parent;</span><br><span class="line">        const key &#x3D; node.key;</span><br><span class="line">        const data &#x3D; node.data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span><br><span class="line">        let res &#x3D; parent;</span><br><span class="line">        if (typeof key !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">            res &#x3D; parent[key] &#x3D; &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (let k in data) &#123;</span><br><span class="line">            if (data.hasOwnProperty(k)) &#123;</span><br><span class="line">                if (typeof data[k] &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 下一次循环</span><br><span class="line">                    loopList.push(&#123;</span><br><span class="line">                        parent: res,</span><br><span class="line">                        key: k,</span><br><span class="line">                        data: data[k]</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    res[k] &#x3D; data[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return roo</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码来源: <a href="https://link.zhihu.com/?target=https%3A//yanhaijing.com/javascript/2018/10/10/clone-deep/">https://yanhaijing.com/javascript/2018/10/10/clone-deep/</a></p>
</blockquote>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>写的时候我一直在想一个问题, 我究竟需不需要自己写一个深拷贝函数或类似的. 对于学习来说这是件无关紧要的事, 但是想要在产品中使用自己写的其实是挺蠢的事. 并不是说我们实现不出来, 而是投入时间的性价比实在太低. 要完成一个工业级别的函数需要大量的测试, 要覆盖到每一种情况,这是件得不偿失的事. 并且是在网上有那么多经过上千场景验证过的现成框架的情况下.所以, 要在合适的情况下选择合适的工具.</p>
<blockquote>
<p>文章参考:<br><a href="https://link.zhihu.com/?target=https%3A//flaviocopes.com/how-to-clone-javascript-object/">https://flaviocopes.com/how-to-clone-javascript-object/</a><br><a href="https://link.zhihu.com/?target=https%3A//yanhaijing.com/javascript/2018/10/10/clone-deep/">https://yanhaijing.com/javascri</a></p>
</blockquote>
<p><font color="red">注：</font>转载于：<a href="https://zhuanlan.zhihu.com/p/61101122" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/61101122</a></p>
<hr>
<h4 id="6-ES6数组方法："><a href="#6-ES6数组方法：" class="headerlink" title="6. ES6数组方法："></a>6. <font color="#00AFF0"><strong>ES6数组方法：</strong></font></h4><h5 id="1-arr-push-从后面添加元素，返回值为添加完后的数组的长度"><a href="#1-arr-push-从后面添加元素，返回值为添加完后的数组的长度" class="headerlink" title="(1)  arr.push() 从后面添加元素，返回值为添加完后的数组的长度"></a>(1)  <code>arr.push()</code> 从后面添加元素，返回值为添加完后的数组的长度</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.push(<span class="number">5</span>))   <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1,2,3,4,5,5]</span></span><br></pre></td></tr></table></figure>

<h5 id="2-arr-pop-从后面删除元素，只能是一个，返回值是删除的元素"><a href="#2-arr-pop-从后面删除元素，只能是一个，返回值是删除的元素" class="headerlink" title="(2)  arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素"></a>(2)  <code>arr.pop()</code> 从后面删除元素，只能是一个，返回值是删除的元素</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.pop())     <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">//[1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<h5 id="3-arr-shift-从前面删除元素，只能删除一个-返回值是删除的元素"><a href="#3-arr-shift-从前面删除元素，只能删除一个-返回值是删除的元素" class="headerlink" title="(3)  arr.shift() 从前面删除元素，只能删除一个 返回值是删除的元素"></a>(3)  <code>arr.shift()</code> 从前面删除元素，只能删除一个 返回值是删除的元素</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.shift())  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)   <span class="comment">// [2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<h5 id="4-arr-unshift-从前面添加元素-返回值是添加完后的数组的长度"><a href="#4-arr-unshift-从前面添加元素-返回值是添加完后的数组的长度" class="headerlink" title="(4)  arr.unshift() 从前面添加元素, 返回值是添加完后的数组的长度"></a>(4)  <code>arr.unshift()</code> 从前面添加元素, 返回值是添加完后的数组的长度</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.unshift(<span class="number">2</span>))    <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">//[2,1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<h5 id="5-arr-splice-i-n-删除从i-索引值-开始之后的那个元素。返回值是删除的元素"><a href="#5-arr-splice-i-n-删除从i-索引值-开始之后的那个元素。返回值是删除的元素" class="headerlink" title="(5)  arr.splice(i,n) 删除从i(索引值)开始之后的那个元素。返回值是删除的元素"></a>(5)  <code>arr.splice(i,n)</code> 删除从i(索引值)开始之后的那个元素。返回值是删除的元素</h5><p>　　参数： i 索引值   n 个数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">2</span>,<span class="number">2</span>))     <span class="comment">//[3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)    <span class="comment">// [1,2,5]</span></span><br></pre></td></tr></table></figure>

<h5 id="6-arr-concat-连接两个数组-返回值为连接后的新数组"><a href="#6-arr-concat-连接两个数组-返回值为连接后的新数组" class="headerlink" title="(6) arr.concat() 连接两个数组 返回值为连接后的新数组"></a>(6) <code>arr.concat()</code> 连接两个数组 返回值为连接后的新数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.concat([<span class="number">1</span>,<span class="number">2</span>]))  <span class="comment">// [1,2,3,4,5,1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)   <span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<h5 id="7-str-split-将字符串转化为数组"><a href="#7-str-split-将字符串转化为数组" class="headerlink" title="(7)  str.split() 将字符串转化为数组"></a>(7)  <code>str.split()</code> 将字符串转化为数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'123456'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">''</span>)) <span class="comment">// ["1", "2", "3", "4", "5", "6"]</span></span><br></pre></td></tr></table></figure>

<h5 id="8-arr-sort-将数组进行排序-返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的，见例子"><a href="#8-arr-sort-将数组进行排序-返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的，见例子" class="headerlink" title="(8)  arr.sort() 将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的，见例子"></a>(8)  <code>arr.sort()</code> 将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的，见例子</h5><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">22</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.sort())   <span class="comment">// [1, 10, 2, 22, 3, 4, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span>a - b)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)   <span class="comment">// [1, 2, 3, 4, 6, 10, 22]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span>b-a)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">// [22, 10, 6, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<h5 id="9-arr-reverse-将数组反转-返回值是反转后的数组"><a href="#9-arr-reverse-将数组反转-返回值是反转后的数组" class="headerlink" title="(9)  arr.reverse() 将数组反转,返回值是反转后的数组"></a>(9)  <code>arr.reverse()</code> 将数组反转,返回值是反转后的数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.reverse())    <span class="comment">// [5,4,3,2,1]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)    <span class="comment">// [5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>

<h5 id="10-arr-slice-start-end-切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组"><a href="#10-arr-slice-start-end-切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组" class="headerlink" title="(10) arr.slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组"></a>(10) <code>arr.slice(start,end)</code> 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">1</span>,<span class="number">3</span>))   <span class="comment">// [2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)    <span class="comment">//  [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<h5 id="11-arr-forEach-callback-遍历数组-无return"><a href="#11-arr-forEach-callback-遍历数组-无return" class="headerlink" title="(11)  arr.forEach(callback) 遍历数组,无return"></a>(11)  <code>arr.forEach(callback)</code> 遍历数组,无return</h5><p>　　 *注意：（伪数组转成真数组才能遍历  <code>Array.prototype.slice.call</code>(伪数组)  ）</p>
<p>​    callback的参数： value –当前索引的值</p>
<p>　　　　　　　　　　index –索引</p>
<p>　　　　　　　　　　array –原数组</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">arr.forEach( <span class="function">(<span class="params">value,index,array</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`value:<span class="subst">$&#123;value&#125;</span>    index:<span class="subst">$&#123;index&#125;</span>     array:<span class="subst">$&#123;array&#125;</span>`</span>)</span><br><span class="line">    &#125;)   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//  value:1    index:0     array:1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  value:2    index:1     array:1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  value:3    index:2     array:1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  value:4    index:3     array:1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  value:5    index:4     array:1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">arr.forEach( <span class="function">(<span class="params">value,index,array</span>)=&gt;</span>&#123;</span><br><span class="line">        value = value * <span class="number">2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`value:<span class="subst">$&#123;value&#125;</span>    index:<span class="subst">$&#123;index&#125;</span>     array:<span class="subst">$&#123;array&#125;</span>`</span>)</span><br><span class="line">    &#125;)   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value:2    index:0     array:1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// value:4    index:1     array:1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// value:6    index:2     array:1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// value:8    index:3     array:1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// value:10   index:4     array:1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<h5 id="12-arr-map-callback-映射数组-遍历数组-有return-返回一个新数组"><a href="#12-arr-map-callback-映射数组-遍历数组-有return-返回一个新数组" class="headerlink" title="(12)  arr.map(callback) 映射数组(遍历数组),有return 返回一个新数组"></a>(12)  <code>arr.map(callback</code>) 映射数组(遍历数组),有return 返回一个新数组</h5><p>　　callback的参数： value –当前索引的值</p>
<p>　　　　　　　　　　index –索引</p>
<p>　　　　　　　　　　array –原数组</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">arr.map( <span class="function">(<span class="params">value,index,array</span>)=&gt;</span>&#123;</span><br><span class="line">        value = value * <span class="number">2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`value:<span class="subst">$&#123;value&#125;</span>    index:<span class="subst">$&#123;index&#125;</span>     array:<span class="subst">$&#123;array&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">&#125;)   </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>ps:</strong> <code>arr.forEach()</code>和<code>arr.map()</code>的区别 </p>
<blockquote>
<p> \1. <code>arr.forEach()</code>是和for循环一样，是代替for。<code>arr.map()</code>是修改数组其中的数据，并返回新的数据。<br> \2. <code>arr.forEach()</code> 没有return <code>arr.map()</code>有return</p>
</blockquote>
<h5 id="13-arr-filter-callback-过滤数组，返回一个满足要求的数组"><a href="#13-arr-filter-callback-过滤数组，返回一个满足要求的数组" class="headerlink" title="(13)  arr.filter(callback) 过滤数组，返回一个满足要求的数组"></a>(13)  <code>arr.filter(callback)</code> 过滤数组，返回一个满足要求的数组</h5><p>  *例如做搜索功能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.filter( <span class="function">(<span class="params">i, v</span>) =&gt;</span> i &lt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)    <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="14-arr-every-callback-依据判断条件，数组的元素是否全满足，若满足则返回ture"><a href="#14-arr-every-callback-依据判断条件，数组的元素是否全满足，若满足则返回ture" class="headerlink" title="(14) arr.every(callback) 依据判断条件，数组的元素是否全满足，若满足则返回ture"></a>(14) <code>arr.every(callback)</code> 依据判断条件，数组的元素是否全满足，若满足则返回ture</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.every( <span class="function">(<span class="params">i, v</span>) =&gt;</span> i &lt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.every( <span class="function">(<span class="params">i, v</span>) =&gt;</span> i &lt; <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2)    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="15-arr-some-依据判断条件，数组的元素是否有一个满足，若有一个满足则返回ture"><a href="#15-arr-some-依据判断条件，数组的元素是否有一个满足，若有一个满足则返回ture" class="headerlink" title="(15)arr.some() 依据判断条件，数组的元素是否有一个满足，若有一个满足则返回ture"></a>(15)<code>arr.some()</code> 依据判断条件，数组的元素是否有一个满足，若有一个满足则返回ture</h5><p>​    *可以做元素在不在数组中的验证</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.some( <span class="function">(<span class="params">i, v</span>) =&gt;</span> i &lt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.some( <span class="function">(<span class="params">i, v</span>) =&gt;</span> i &gt; <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2)    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="16-arr-reduce-callback-initialValue-迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值"><a href="#16-arr-reduce-callback-initialValue-迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值" class="headerlink" title="(16) arr.reduce(callback, initialValue) 迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值"></a>(16) <code>arr.reduce(callback, initialValue)</code> 迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值</h5><p>　　参数： <code>callback</code>: <code>previousValue</code> 必选 –上一次调用回调返回的值，或者是提供的初始值（<code>initialValue</code>）</p>
<p>　　　　　　　　　　<code>currentValue</code> 必选 –数组中当前被处理的数组项</p>
<p>　　　　　　　　　　index 可选 –当前数组项在数组中的索引值</p>
<p>　　　　　　　　　　array 可选 –原数组</p>
<p>　　　　　<code>initialValue</code>: 可选 –初始值</p>
<p>　　实行方法：回调函数第一次执行时，<code>preValue</code> 和 <code>curValue</code> 可以是一个值，如果 <code>initialValue</code> 在调用 <code>reduce()</code> 时被提供，那么第一个 preValue 等于<code>initialValue</code> ，并且<code>curValue</code> 等于数组中的第一个值；如果<code>initialValue</code> 未被提供，那么<code>preValue</code> 等于数组中的第一个值.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.reduce(<span class="function">(<span class="params">preValue, curValue</span>) =&gt;</span> </span><br><span class="line"></span><br><span class="line">    preValue + curValue</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/1211722/201803/1211722-20180308153541708-1358020026.png" alt="img"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr.reduce(<span class="function">(<span class="params">preValue,curValue</span>)=&gt;</span>preValue + curValue,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2)    <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/1211722/201803/1211722-20180308153617829-2032934804.png" alt="img"></p>
<h5 id="17-arr-reduceRight-callback-initialValue-与arr-reduce-功能一样，不同的是，reduceRight-从数组的末尾向前将数组中的数组项做累加。"><a href="#17-arr-reduceRight-callback-initialValue-与arr-reduce-功能一样，不同的是，reduceRight-从数组的末尾向前将数组中的数组项做累加。" class="headerlink" title="(17) arr.reduceRight(callback, initialValue) 与arr.reduce()功能一样，不同的是，reduceRight()从数组的末尾向前将数组中的数组项做累加。"></a>(17) <code>arr.reduceRight(callback, initialValue)</code> 与<code>arr.reduce()</code>功能一样，不同的是，<code>reduceRight()</code>从数组的末尾向前将数组中的数组项做累加。</h5><p>　　实行方法：<code>reduceRight()</code>首次调用回调函数<code>callbackfn</code>时，<code>prevValue</code> 和 <code>curValue</code> 可以是两个值之一。如果调用 <code>reduceRight()</code> 时提供了 <code>initialValue</code> 参数，则 <code>prevValue</code> 等于<code>initialValue</code>，<code>curValue</code> 等于数组中的最后一个值。如果没有提供 <code>initialValue</code> 参数，则 <code>prevValue</code> 等于数组最后一个值，<code>curValue</code> 等于数组中倒数第二个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.reduceRight(<span class="function">(<span class="params">preValue, curValue</span>) =&gt;</span> </span><br><span class="line">    preValue + curValue</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)    <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/1211722/201803/1211722-20180308153737645-1247600177.png" alt="img"></p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr2 = arr.reduceRight((preValue,curValue)=&gt;preValue + curValue,5)</span><br><span class="line"></span><br><span class="line">console.log(arr2)    // 15</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/1211722/201803/1211722-20180308153807868-61009587.png" alt="img"></p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>ps：</strong></p>
<p>(如果对这两个方法不明白，可以查看大漠老师的实例 <a href="http://www.w3cplus.com/javascript/array-part-8.html" target="_blank" rel="noopener">http://www.w3cplus.com/javascript/array-part-8.html</a>)</p>
<h5 id="18-arr-indexOf-查找某个元素的索引值，若有重复的，则返回第一个查到的索引值若不存在，则返回-1"><a href="#18-arr-indexOf-查找某个元素的索引值，若有重复的，则返回第一个查到的索引值若不存在，则返回-1" class="headerlink" title="(18)arr.indexOf() 查找某个元素的索引值，若有重复的，则返回第一个查到的索引值若不存在，则返回 -1"></a>(18)<code>arr.indexOf()</code> 查找某个元素的索引值，若有重复的，则返回第一个查到的索引值若不存在，则返回 -1</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.indexOf(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.indexOf(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h5 id="19-arr-lastIndexOf-和arr-indexOf-的功能一样，不同的是从后往前查找"><a href="#19-arr-lastIndexOf-和arr-indexOf-的功能一样，不同的是从后往前查找" class="headerlink" title="(19)arr.lastIndexOf()  和arr.indexOf()的功能一样，不同的是从后往前查找"></a>(19)<code>arr.lastIndexOf()</code>  和<code>arr.indexOf()</code>的功能一样，不同的是从后往前查找</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.lastIndexOf(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.lastIndexOf(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2)  <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<h5 id="20-Array-from-将伪数组变成数组，就是只要有length的就可以转成数组。-—es6"><a href="#20-Array-from-将伪数组变成数组，就是只要有length的就可以转成数组。-—es6" class="headerlink" title="(20)Array.from() 将伪数组变成数组，就是只要有length的就可以转成数组。 —es6"></a>(20)<code>Array.from()</code> 将伪数组变成数组，就是只要有length的就可以转成数组。 —es6</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'12345'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(str))    <span class="comment">// ["1", "2", "3", "4", "5"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="number">0</span>:<span class="string">'a'</span>,<span class="number">1</span>:<span class="string">'b'</span>,<span class="attr">length</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(obj))   <span class="comment">// ["a", "b"]</span></span><br></pre></td></tr></table></figure>

<h5 id="21-Array-of-将一组值转换成数组，类似于声明数组-—es6"><a href="#21-Array-of-将一组值转换成数组，类似于声明数组-—es6" class="headerlink" title="(21) Array.of()将一组值转换成数组，类似于声明数组  —es6"></a>(21) <code>Array.of()</code>将一组值转换成数组，类似于声明数组  —es6</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'11'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(str))   <span class="comment">// ['11']</span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'11'</span>))  <span class="comment">// ['11]</span></span><br></pre></td></tr></table></figure>

<p><strong>ps:</strong></p>
<p>但是new Array()有缺点，就是参数问题引起的重载</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>))   <span class="comment">//[empty × 2]  是个空数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">2</span>))    <span class="comment">// [2]</span></span><br></pre></td></tr></table></figure>

<h5 id="22-arr-copyWithin-在当前数组内部，将制定位置的数组复制到其他位置，会覆盖原数组项，返回当前数组"><a href="#22-arr-copyWithin-在当前数组内部，将制定位置的数组复制到其他位置，会覆盖原数组项，返回当前数组" class="headerlink" title="(22) arr.copyWithin() 在当前数组内部，将制定位置的数组复制到其他位置，会覆盖原数组项，返回当前数组"></a>(22) <code>arr.copyWithin()</code> 在当前数组内部，将制定位置的数组复制到其他位置，会覆盖原数组项，返回当前数组</h5><p>　　参数: target –必选 索引从该位置开始替换数组项</p>
<p>　　　　 start –可选 索引从该位置开始读取数组项，默认为0.如果为负值，则从右往左读。</p>
<p>　　　　 end –可选 索引到该位置停止读取的数组项，默认是Array.length,如果是负值，表示倒数</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.copyWithin(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)   <span class="comment">// [1, 1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.copyWithin(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2)   <span class="comment">// [1, 3, 4, 5, 6, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = arr.copyWithin(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr3)   <span class="comment">// [1, 3, 4, 4, 5, 6, 7]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<h5 id="23-arr-find-callback-找到第一个符合条件的数组成员"><a href="#23-arr-find-callback-找到第一个符合条件的数组成员" class="headerlink" title="(23) arr.find(callback) 找到第一个符合条件的数组成员"></a>(23) <code>arr.find(callback)</code> 找到第一个符合条件的数组成员</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.find(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span>value &gt; <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h5 id="24-arr-findIndex-callback-找到第一个符合条件的数组成员的索引值"><a href="#24-arr-findIndex-callback-找到第一个符合条件的数组成员的索引值" class="headerlink" title="(24) arr.findIndex(callback) 找到第一个符合条件的数组成员的索引值"></a>(24) <code>arr.findIndex(callback)</code> 找到第一个符合条件的数组成员的索引值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.findIndex(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span> value &gt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h5 id="25-arr-fill-target-start-end-使用给定的值，填充一个数组-ps-填充完后会改变原数组"><a href="#25-arr-fill-target-start-end-使用给定的值，填充一个数组-ps-填充完后会改变原数组" class="headerlink" title="(25) arr.fill(target, start, end) 使用给定的值，填充一个数组,ps:填充完后会改变原数组"></a>(25) <code>arr.fill(target, start, end)</code> 使用给定的值，填充一个数组,ps:填充完后会改变原数组</h5><p>　　参数： target – 待填充的元素</p>
<p>　　　　　 start – 开始填充的位置-索引</p>
<p>　　　　  end – 终止填充的位置-索引（不包括该位置)</p>
<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.fill(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr1)  <span class="comment">// [5, 5, 5, 5, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)   <span class="comment">// [5, 5, 5, 5, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.fill(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br><span class="line">et arr3 = arr.fill(<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr3)</span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<h5 id="26-arr-includes-判断数中是否包含给定的值"><a href="#26-arr-includes-判断数中是否包含给定的值" class="headerlink" title="(26) arr.includes() 判断数中是否包含给定的值"></a>(26) <code>arr.includes()</code> 判断数中是否包含给定的值</h5><p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.includes(<span class="number">2</span>)  </span><br><span class="line">onsole.log(arr1)   <span class="comment">// ture</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.includes(<span class="number">9</span>) </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2)    <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr3)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></p>
<p><strong>ps:</strong>与<code>indexOf()</code>的区别：</p>
<blockquote>
<p>1 <code>indexOf()</code>返回的是数值，而<code>includes()</code>返回的是布尔值</p>
<p>2<code>indexOf()</code> 不能判断<code>NaN</code>，返回为-1 ，includes()则可以判断</p>
</blockquote>
<h5 id="27-arr-keys-遍历数组的键名"><a href="#27-arr-keys-遍历数组的键名" class="headerlink" title="(27) arr.keys() 遍历数组的键名"></a>(27) <code>arr.keys()</code> 遍历数组的键名</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = arr.keys()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> arr2) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(key);   <span class="comment">// 0,1,2,3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="28-arr-values-遍历数组键值"><a href="#28-arr-values-遍历数组键值" class="headerlink" title="(28) arr.values() 遍历数组键值"></a>(28) <code>arr.values()</code> 遍历数组键值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.values()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> val <span class="keyword">of</span> arr1) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(val);   <span class="comment">// 1,2,3,4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="29-arr-entries-遍历数组的键名和键值"><a href="#29-arr-entries-遍历数组的键名和键值" class="headerlink" title="(29) arr.entries() 遍历数组的键名和键值"></a>(29) <code>arr.entries()</code> 遍历数组的键名和键值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.entries()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> arr1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);   <span class="comment">// 1,2,3,4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">注：</font>转载于：<a href="https://blog.csdn.net/weixin_42805130/article/details/89395001" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42805130/article/details/89395001</a></p>
<hr>
<h5 id="6-1-新提案（ES6数组方法）："><a href="#6-1-新提案（ES6数组方法）：" class="headerlink" title="6 - 1. 新提案（ES6数组方法）："></a>6 - 1. <font color="#00AFF0"><strong>新提案（ES6数组方法）：</strong></font></h5><h6 id="1-Array-at"><a href="#1-Array-at" class="headerlink" title="(1) Array.at()"></a>(1) <code>Array.at()</code></h6><p>JavaScript 数组的索引是从0开始的，第一个元素的索引为0，最后一个元素的索引等于该数组的长度减1。</p>
<p>在之前，我们一般使用方括号通过索引访问数组元素：<code>array[index]</code>，如果指定的索引是一个无效值，JavaScript 数组并不会报错，而是会返回 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'apple'</span>, <span class="string">'banner'</span>, <span class="string">'pear'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>])  <span class="comment">// 'apple'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>])  <span class="comment">// 'banner'</span></span><br></pre></td></tr></table></figure>

<p>在大多数情况下，方括号语法是通过正索引访问数组元素的好方法。</p>
<p>但有时我们希望从末尾而不是从头开始访问元素。例如，访问数组的最后一个元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'apple'</span>, <span class="string">'banner'</span>, <span class="string">'pear'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr[arr.length - <span class="number">1</span>]) <span class="comment">// 'pear'</span></span><br></pre></td></tr></table></figure>

<p>现在，数组提供了一个新的方法来访问数组元素：<code>Array.prototype.at()</code>。</p>
<p><code>at()</code> 方法接收一个整数值并返回该索引的项目，允许正数和负数。负整数从数组中的最后一个项目开始倒数。</p>
<p>方括号符号没有问题，但对于后面的项目，可以调用<code>array.at(-1)</code>，无须再访问 array.length (参见以下示例)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'apple'</span>, <span class="string">'banner'</span>, <span class="string">'pear'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.at(<span class="number">0</span>))   <span class="comment">// 'apple'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.at(<span class="number">-2</span>))  <span class="comment">// 'banner'</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.at(<span class="number">-1</span>))  <span class="comment">// 'pear'</span></span><br></pre></td></tr></table></figure>



<h6 id="2-Array-reduce-callback-initialValue"><a href="#2-Array-reduce-callback-initialValue" class="headerlink" title="(2) Array.reduce(callback, [initialValue])"></a>(2) <code>Array.reduce(callback, [initialValue])</code></h6><p>该方法接收一个函数作为累加器，数组中的每个值（从左到右）开始合并，最终计算为一个值</p>
<blockquote>
<p><code>callback(prev, cur, index, array)</code>：执行数组中每个值的函数，包含四个参数。必选。</p>
<ul>
<li><p><code>previousValue</code>：上一次调用 callbackFn 时的返回值。在第一次调用时，若指定了初始值 initialValue，其值则为 initialValue，否则为数组索引为 0 的元素  array[0]。必选。</p>
</li>
<li><p><code>currentValue</code>：数组中正在处理的元素。在第一次调用时，若指定了初始值 initialValue，其值则为数组索引为 0 的元素 array[0]，否则为 array[1]。必选。</p>
</li>
<li><p><code>currentIndex</code>：数组中正在处理的元素的索引。若指定了初始值 initialValue，则起始索引号为 0，否则从索引 1 起始。可选。</p>
</li>
<li><p><code>array</code>：用于遍历的数组，可选。</p>
</li>
</ul>
<p><code>initialValue</code>：作为第一次调用 callback 的第一个参数，可选。</p>
<ul>
<li>作为第一次调用 callback 函数时参数 previousValue 的值。若指定了初始值 initialValue，则 currentValue 则将使用数组第一个元素；否则 previousValue 将使用数组第一个元素，而 currentValue 将使用数组第二个元素。</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, cur, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 输出的是第一项的值或者上一次叠加的结果，正在被处理的元素，正在被处理的元素的索引值</span></span><br><span class="line">  <span class="built_in">console</span>.log(prev, cur, index)</span><br><span class="line">  <span class="keyword">return</span> prev + cur</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出(prev, cur, index)</span></span><br><span class="line"><span class="comment">// 1 2 1</span></span><br><span class="line"><span class="comment">// 3 3 2</span></span><br><span class="line"><span class="comment">// 6 4 3</span></span><br><span class="line"><span class="comment">// 10 5 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'arr'</span>, arr) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sum'</span>, sum) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>



<h6 id="3-JavaScript映射器-Array-flatMap"><a href="#3-JavaScript映射器-Array-flatMap" class="headerlink" title="(3) JavaScript映射器: Array.flatMap()"></a>(3) <code>JavaScript映射器: Array.flatMap()</code></h6><p><code>array.map()</code>是一个非常有用的映射函数：它接收一个数组和一个映射函数，然后返回一个新的映射数组。</p>
<p>然而，有一个替代 <code>array.map()</code>的方法：<code>array.flatMap()</code>（从ES2019开始可用）。这个方法给了我们映射的能力，但也可以在生成的映射数组中删除甚至添加新的项目。</p>
<p><strong>更加智能的映射器</strong>：</p>
<p>有一个数字数组，我们要如何创建一个新的数组，使用每个数字加倍？</p>
<p>使用<code>array.map()</code>函数是一个好方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.map(<span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(doubled) <span class="comment">// logs [0, 6, 12]</span></span><br></pre></td></tr></table></figure>

<p><code>numbers.map(number =&gt; 2 * number)</code> 将 <code>number</code> 数组映射到一个新的数组，其中每个数字都被翻倍。</p>
<p>对于需要一对一映射的情况，也就是说，映射后的数组与原始数组的项数相同，<code>array.map()</code>的效果非常好。</p>
<p>但如果我们需要将一个数组的数字翻倍，同时跳为<code>0</code>的项，该怎么办？</p>
<p>直接使用 <code>array.map()</code> 是不可能的，因为该方法总是创建一个映射的数组，其项数与原数组相同。但是我们可以使用 <code>array.map()</code>和 <code>array.filter()</code> 的组合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> doubled = numbers</span><br><span class="line">  .filter(<span class="function"><span class="params">n</span> =&gt;</span> n !== <span class="number">0</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(doubled); <span class="comment">// logs [6, 12]</span></span><br></pre></td></tr></table></figure>

<p><code>array.map()</code>和 <code>array.filter()</code> 可以解决问题，但有没有更简短的方法？</p>
<p>必须滴。使用 <code>array.flatMap()</code> 方法，只需调用一个方法就可以执行映射和删除项目。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.flatMap(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> number === <span class="number">0</span> ? [] : [<span class="number">2</span> * number]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(doubled) <span class="comment">// logs [6, 12]</span></span><br></pre></td></tr></table></figure>

<p>通过只使用 <code>numbers.flatMap()</code>，你可以将一个数组映射到另一个数组，但也可以从映射中跳过某些元素。</p>
<p>接着，我们来更详细地看看 <code>array.flatMap()</code>是如何工作的。</p>
<p><strong><code>array.flatMap()</code></strong>：</p>
<p><code>array.flatMap()</code> 函数接受一个回调函数作为参数并返回一个新的映射数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mappedArray = array.flatMap(<span class="function">(<span class="params">item, index, origArray</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> [value1, value2, ..., valueN]</span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>

<p>回调函数在原数组中的每个iteam上被调用，有3个参数：当前项、索引和原数组。然后，回调函数返回的数组被扁平化了1层，得到的项目被添加到映射的数组中。</p>
<p>此外，该方法还接受第二个可选参数，表示回调内部的 <code>this</code> 值。</p>
<p>使用 <code>array.flatmap()</code>最简单的方法是将包含项目的数组扁平化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrays = [[<span class="number">2</span>, <span class="number">4</span>], [<span class="number">6</span>]]</span><br><span class="line"><span class="keyword">const</span> flatten = arrays.flatMap(<span class="function"><span class="params">item</span> =&gt;</span> item)</span><br><span class="line"><span class="built_in">console</span>.log(flatten) <span class="comment">// logs [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<p>但是<code>array.flatMap()</code>除了简单的扁平化之外，还可以做更多的事情。通过控制从回调中返回的数组项的数量：</p>
<ul>
<li>通过返回一个空数组从结果数组中删除该项</li>
<li>通过返回一个带有一个新值的数组 <code>[newValue]</code> 来修改映射的项</li>
<li>通过返回一个包含多个值的数组来添加新项: <code>[newValue1, newValue2, ...]</code></li>
</ul>
<p>例如，正如你在上一节中所看到的，可以通过将项目加倍来创建一个新的数组，但同时也要删除 <code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> doubled = numbers.flatMap(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> number === <span class="number">0</span> ? [] : [<span class="number">2</span> * number]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(doubled) <span class="comment">// logs [6, 12]</span></span><br></pre></td></tr></table></figure>

<p>现在，我们来看下它是怎么工作的。</p>
<p>如果当前项为 <code>0</code>，回调函数返回一个空数组 <code>[]</code>。这意味着当被扁平化时，空数组<code>[]</code>没有提供任何值。</p>
<p>如果当前迭代项非零，则返回 <code>[2 * number]</code>。当扁平<code>[2 * number]</code>数组时，结果数组中只添加<code>2 * number</code>。</p>
<p>你也可以使用 <code>array.flatMap()</code>来增加映射的数组中的项目数量。</p>
<p>例如，下面的代码片段通过添加两倍和三倍的数字将一个数字数组映射到一个新数组:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> trippled = numbers.flatMap(<span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [number, <span class="number">2</span> * number, <span class="number">3</span> * number]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(trippled)</span><br><span class="line"><span class="comment">// logs [1, 2, 3, 4, 8, 12]</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<p>如果你想把一个数组映射到一个新的数组中，同时又能控制你想在新的映射数组中添加多少项，那么 <code>array.flatMap()</code> 方法就是一个好办法。</p>
<p><code>array.flatMap(callback)</code> 的回调函数被调用，有3个参数：当前迭代的项、索引和原始数组。然后，从回调函数返回的数组在<code>1</code>层深处被扁平化，得到的项目被插入到所产生的映射数组中。</p>
<h6 id="4-JavaScript-新提案：array-groupBy"><a href="#4-JavaScript-新提案：array-groupBy" class="headerlink" title="(4) JavaScript 新提案：array.groupBy()"></a>(4) <code>JavaScript 新提案：array.groupBy()</code></h6><p><code>array.groupBy()</code></p>
<p>假设我们有一个产品列表，其中每个产品都是一个具有2个属性的对象: name 和 category。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> products = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'apples'</span>, <span class="attr">category</span>: <span class="string">'fruits'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'oranges'</span>, <span class="attr">category</span>: <span class="string">'fruits'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'potatoes'</span>, <span class="attr">category</span>: <span class="string">'vegetables'</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>products</code> 是一个产品对象数组。</p>
<p>现在，对产品列表执行一个简单的操作，将产品按类别分组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> groupByCategory = &#123;</span><br><span class="line">  <span class="string">'fruits'</span>: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'apples'</span>, <span class="attr">category</span>: <span class="string">'fruits'</span> &#125;, </span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'oranges'</span>, <span class="attr">category</span>: <span class="string">'fruits'</span> &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">'vegetables'</span>: [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">'potatoes'</span>, <span class="attr">category</span>: <span class="string">'vegetables'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何从 <code>products</code> 数组中得到一个类似 <code>groupByCategory</code> 的数组？</p>
<p>通常的方法是使用<code>array.reduce()</code>来实现，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> products = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'apples'</span>, <span class="attr">category</span>: <span class="string">'fruits'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'oranges'</span>, <span class="attr">category</span>: <span class="string">'fruits'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'potatoes'</span>, <span class="attr">category</span>: <span class="string">'vegetables'</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> groupByCategory = products.reduce(<span class="function">(<span class="params">group, product</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; category &#125; = product</span><br><span class="line">  group[category] = group[category] ?? []</span><br><span class="line">  group[category].push(product)</span><br><span class="line">  <span class="keyword">return</span> group</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(groupByCategory)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   'fruits': [</span></span><br><span class="line"><span class="comment">//     &#123; name: 'apples', category: 'fruits' &#125;, </span></span><br><span class="line"><span class="comment">//     &#123; name: 'oranges', category: 'fruits' &#125;,</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   'vegetables': [</span></span><br><span class="line"><span class="comment">//     &#123; name: 'potatoes', category: 'vegetables' &#125;</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>products.reduce((acc, product) =&gt; { ... })</code> 将产品数组还原为一个按类别分组的产品对象。</p>
<p><code>array.reduce()</code>方法有用且强大，但有时它的可读性并不是最好的。</p>
<p>因为分组数据是常见的事(从SQL中召回groupby ?)，数组组提案引入了两个有用的方法:<code>array. groupBy()</code>和 <code>array.groupByToMap()</code>。</p>
<p>下面介绍如何使用 <code>array.groupBy()</code> 创建相同的分类分组：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> products = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'apples'</span>, <span class="attr">category</span>: <span class="string">'fruits'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'oranges'</span>, <span class="attr">category</span>: <span class="string">'fruits'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'potatoes'</span>, <span class="attr">category</span>: <span class="string">'vegetables'</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> groupByCategory = products.groupBy(<span class="function"><span class="params">product</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> product.category</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(groupByCategory)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   'fruits': [</span></span><br><span class="line"><span class="comment">//     &#123; name: 'apples', category: 'fruits' &#125;, </span></span><br><span class="line"><span class="comment">//     &#123; name: 'oranges', category: 'fruits' &#125;,</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   'vegetables': [</span></span><br><span class="line"><span class="comment">//     &#123; name: 'potatoes', category: 'vegetables' &#125;</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>products.groupBy(product =&gt; {...})</code> 返回一个对象，其中每个属性的键是类别名称，值是对应类别的产品数组。</p>
<p>使用 <code>products.groupBy()</code> 分组比使用 <code>product.reduce()</code> 代码更少，更容易理解。</p>
<p><code>array.groupBy(callback)</code> 接受一个回调函数，该函数被调用时有3个参数：当前数组项、索引和数组本身。回调函数应该返回一个字符串：你想添加项目的组名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> groupedObject = array.groupBy(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> groupNameAsString</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p><code>array.groupByToMap()</code></p>
<p>有时你可能想使用 <code>Map</code> 而不是普通对象。 <code>Map</code> 的好处是它可以接受任何数据类型作为键，但普通对象只限于字符串和 symbol。</p>
<p>恩，如果你想把数据分组到一个Map中，你可以使用 <code>array.groupByToMap()</code> 方法。</p>
<p><code>array.groupByToMap(callback)</code>的工作方式与 <code>array.groupBy(callback)</code> 完全一样，只是它将项目分组到 <code>Map</code> 中，而不是一个普通的 JS 对象中。</p>
<p>例如，将产品数组按类别名称分组到一个 Map 中，执行方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> products = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'apples'</span>, <span class="attr">category</span>: <span class="string">'fruits'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'oranges'</span>, <span class="attr">category</span>: <span class="string">'fruits'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'potatoes'</span>, <span class="attr">category</span>: <span class="string">'vegetables'</span> &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> groupByCategory = products.groupByToMap(<span class="function"><span class="params">product</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> product.category</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(groupByCategory)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map([</span></span><br><span class="line"><span class="comment">//   ['fruits', [</span></span><br><span class="line"><span class="comment">//     &#123; name: 'apples', category: 'fruits' &#125;, </span></span><br><span class="line"><span class="comment">//     &#123; name: 'oranges', category: 'fruits' &#125;,</span></span><br><span class="line"><span class="comment">//   ]],</span></span><br><span class="line"><span class="comment">//   ['vegetables', [</span></span><br><span class="line"><span class="comment">//     &#123; name: 'potatoes', category: 'vegetables' &#125;</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// ])</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<blockquote>
<p>如果你想轻松地对数组中的项进行分组（类似于SQL中的<code>GROUP BY</code>），那么欢迎使用新方法<code>array.groupBy()</code> 和 <code>array.groupByToMap()</code>。</p>
<p>两个函数都接受一个回调函数，该回调函数应返回必须插入当前项的组的键。</p>
<p><code>array.groupBy()</code>将这些项分组为一个普通的JavaScript对象，而<code>array.groupByToMap()</code>将它们分组为一个 <code>Map</code> 实例。</p>
<p>如果你想马上使用这些函数，那么使用 <code>core-js</code> 库提供的 polyfill。</p>
</blockquote>
<h6 id="5-findLast"><a href="#5-findLast" class="headerlink" title="(5) findLast()"></a>(5) <code>findLast()</code></h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLast</span>(<span class="params">arr, callback, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = arr.length<span class="number">-1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = arr[index]</span><br><span class="line">    <span class="keyword">if</span> (callback.call(thisArg, value, index, arr)) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="6-findLastIndex"><a href="#6-findLastIndex" class="headerlink" title="(6) findLastIndex()"></a>(6) <code>findLastIndex()</code></h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLastIndex</span>(<span class="params">arr, callback, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = arr.length<span class="number">-1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = arr[index]</span><br><span class="line">    <span class="keyword">if</span> (callback.call(thisArg, value, index, arr)) &#123;</span><br><span class="line">      <span class="keyword">return</span> index</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="7-arr-sort"><a href="#7-arr-sort" class="headerlink" title="(7) arr.sort()"></a>(7) <code>arr.sort()</code></h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">arr = arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// return -1 返回负值	交换顺序</span></span><br><span class="line">  <span class="comment">// return 0 || 1	返回正值	保持顺序不变</span></span><br><span class="line">  <span class="built_in">console</span>.log(a, b)</span><br><span class="line">  <span class="keyword">return</span> b - a</span><br><span class="line">  <span class="comment">// a - b 从小到大</span></span><br><span class="line">  <span class="comment">// b - a 从大到小</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-ES6新增语法："><a href="#7-ES6新增语法：" class="headerlink" title="7. ES6新增语法："></a>7. <font color="#00AFF0"><strong>ES6新增语法：</strong></font></h4><p><img src="https://pic1.zhimg.com/v2-ac1433da3e2bd7994c96bae11692bc40_1440w.jpg?source=172ae18b" alt="ES6新增语法"></p>
<h5 id="（一）let-和-const"><a href="#（一）let-和-const" class="headerlink" title="（一）let 和 const"></a>（一）let 和 const</h5><h6 id="1-let"><a href="#1-let" class="headerlink" title="1) let"></a>1) let</h6><ul>
<li>let 定义变量，变量不可以再次定义，但可以改变其值</li>
</ul>
<p>代码举例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'zhangsan'</span>;</span><br><span class="line">name = <span class="string">'lisi'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// lisi</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'wangwu'</span>; <span class="comment">// 再次定义，报错：Identifier 'name' has already been declared</span></span><br></pre></td></tr></table></figure>

<ul>
<li>具有块级作用域。（即大括号）</li>
</ul>
<p>代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(age); <span class="comment">// 18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">// 报错，此作用域中没有age的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// i 只能在此范围内使用，因为有块级作用域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">// 报错，此作用域中没有i的定义</span></span><br></pre></td></tr></table></figure>

<ul>
<li>没有变量提升，必须先定义再使用</li>
</ul>
<p>代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(gender); <span class="comment">// 报错，此时还没有定义gender</span></span><br><span class="line"><span class="keyword">let</span> gender = <span class="string">'男'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>let声明的变量不会压到window对象中，是独立的</li>
</ul>
<p>代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> hobby = <span class="string">'吃饭'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.hobby); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>如果使用var声明了变量，也不能再次用let声明了，反之也是不行的。原因也是这个变量已经被声明过了。</strong></p>
<h6 id="2-const"><a href="#2-const" class="headerlink" title="2) const"></a>2) const</h6><ul>
<li>使用const关键字定义常量</li>
<li>常量是不可变的，一旦定义，则不能修改其值</li>
</ul>
<p>代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用const关键字定义常量，常量名一般大写</span></span><br><span class="line"><span class="comment">// 2. 常量是不可变的，一旦定义，则不能修改其值</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415926</span>；</span><br><span class="line">PI = <span class="number">3.14</span>; <span class="comment">// 报错，常用一旦被初始化，则不能被修改</span></span><br></pre></td></tr></table></figure>

<ul>
<li>初始化常量时，必须给初始值</li>
</ul>
<p>代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI; </span><br><span class="line"><span class="comment">// 报错，Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>

<ul>
<li>具有块级作用域</li>
<li>没有变量提升，必须先定义再使用</li>
<li>常量也是独立的，定义后不会压入到window对象中</li>
</ul>
<h6 id="3-总结"><a href="#3-总结" class="headerlink" title="3) 总结"></a>3) 总结</h6><p><img src="https:////upload-images.jianshu.io/upload_images/16799285-b2e53c6131be72ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/651/format/webp" alt="img"></p>
<h5 id="（二）解构赋值"><a href="#（二）解构赋值" class="headerlink" title="（二）解构赋值"></a>（二）解构赋值</h5><h6 id="1-数组解构"><a href="#1-数组解构" class="headerlink" title="1) 数组解构"></a>1) 数组解构</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况1，变量和值一一对应</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 输出 5 9 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2，变量多，值少</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b, c, d] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d); <span class="comment">// 输出 5 9 10 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况3，变量少，值多</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 5, 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况4，按需取值</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [, , a, , b] = arr; <span class="comment">// 不需要用变量接收的值，用空位占位</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 10, 3 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况5，剩余值</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b, ...c] = arr; <span class="comment">// ...c 接收剩余的其他值，得到的c是一个数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); </span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// a = 5, </span></span><br><span class="line"><span class="comment">// b = 9, </span></span><br><span class="line"><span class="comment">// c = [10, 8, 3, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况6，复杂的情况，只要符合模式，即可解构</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'zhangsan'</span>, <span class="number">18</span>, [<span class="string">'175cm'</span>, <span class="string">'65kg'</span>]];</span><br><span class="line"><span class="keyword">let</span> [, , [a, b]] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 175cm 65kg</span></span><br></pre></td></tr></table></figure>

<h6 id="2-对象解构"><a href="#2-对象解构" class="headerlink" title="2) 对象解构"></a>2) 对象解构</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况1，默认要求变量名和属性名一样</span></span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = &#123;<span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo, bar); <span class="comment">// aaa, bbb</span></span><br><span class="line"><span class="keyword">let</span> &#123;a, c&#125; = &#123;<span class="attr">a</span>: <span class="string">'hello'</span>, <span class="attr">b</span>: <span class="string">'world'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a, c); <span class="comment">// hello, undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况2，可以通过:为变量改名</span></span><br><span class="line"><span class="keyword">let</span> &#123;a, <span class="attr">b</span>:c&#125; = &#123;<span class="attr">a</span>: <span class="string">'hello'</span>, <span class="attr">b</span>: <span class="string">'world'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a, c); <span class="comment">// hello, world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况3，变量名和属性名一致即可获取到值，不一定要一一对应</span></span><br><span class="line"><span class="keyword">let</span> &#123;b&#125; = &#123;<span class="attr">a</span>: <span class="string">'hello'</span>, <span class="attr">b</span>: <span class="string">'world'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// world</span></span><br><span class="line"><span class="comment">// 此时，没有定义变量a，所以使用a会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况4，剩余值</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">'zs'</span>, <span class="attr">age</span>:<span class="number">20</span>, <span class="attr">gender</span>:<span class="string">'男'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name, ...a&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, a);</span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// name = zs</span></span><br><span class="line"><span class="comment">// a = &#123;age: 20, gender: "男"&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况5，复杂的情况，只要符合模式，即可解构</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'zhangsan'</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    dog: &#123;</span><br><span class="line">        name: <span class="string">'毛毛'</span>,</span><br><span class="line">        age: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">dog</span>: &#123;name, age&#125;&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(name, age); <span class="comment">// 毛毛 3</span></span><br></pre></td></tr></table></figure>

<h5 id="（三）函数和参数"><a href="#（三）函数和参数" class="headerlink" title="（三）函数和参数"></a>（三）函数和参数</h5><h6 id="1-箭头函数"><a href="#1-箭头函数" class="headerlink" title="1) 箭头函数"></a>1) 箭头函数</h6><p>使用箭头定义函数 <code>=&gt; goes to</code>，目的是<strong>简化函数的定义</strong>并且里面的this也比较特殊。</p>
<p>基本定义：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非箭头函数</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数，等同于上面的函数</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>形参只有一个可以省略小括号</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数体只有一句话，可以省略大括号，并且表示返回函数体的内容</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>

<ul>
<li>箭头函数内部没有 arguments</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// 报错，arguments is not defined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>箭头函数内部的 <code>this</code> 指向外部作用域中的 <code>this</code> ，或者可以认为箭头函数没有自己的 <code>this</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里必须用var，因为用let声明的变量不能使用window调用</span></span><br><span class="line">   <span class="keyword">var</span> name = <span class="string">'lisi'</span>;</span><br><span class="line">   <span class="keyword">let</span> obj = &#123;</span><br><span class="line">       name: <span class="string">'zhangsan'</span>,</span><br><span class="line">       fn: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window对象</span></span><br><span class="line">           <span class="built_in">console</span>.log(<span class="keyword">this</span>.name); <span class="comment">// lisi</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   obj.fn();</span><br></pre></td></tr></table></figure>

<ul>
<li>箭头函数不能作为构造函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Person = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Person(); <span class="comment">// 报错，Person is not a constructor</span></span><br><span class="line"><span class="comment">// 箭头函数中都没有自己的this，不能处理成员，所以不能当构造函数</span></span><br></pre></td></tr></table></figure>

<h6 id="2-参数的默认值"><a href="#2-参数的默认值" class="headerlink" title="2) 参数的默认值"></a>2) 参数的默认值</h6><p>ES6中可以给函数的参数设置默认值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y = <span class="string">'world'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">2</span>)</span><br><span class="line">fn(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="comment">//2 “world”</span></span><br><span class="line"><span class="comment">//2 3</span></span><br></pre></td></tr></table></figure>

<h6 id="3-rest参数"><a href="#3-rest参数" class="headerlink" title="3) rest参数"></a>3) rest参数</h6><p>剩余参数，以 <code>…</code>修饰<strong>最后</strong>一个参数，把多余的参数都放到一个<strong>数组</strong>中。可以替代 <strong>arguments</strong> 的使用。<br> <strong>rest 参数只能是最后一个参数。</strong></p>
<p>代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数很多，不确定多少个，可以使用剩余参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(values); <span class="comment">// [6, 1, 100, 9, 10]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">6</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">9</span>, <span class="number">10</span>)); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, ...values</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 6</span></span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(values); <span class="comment">// [100, 9, 10]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">6</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">9</span>, <span class="number">10</span>)); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="（四）内置函数的扩展"><a href="#（四）内置函数的扩展" class="headerlink" title="（四）内置函数的扩展"></a>（四）内置函数的扩展</h5><h6 id="1-扩展运算符："><a href="#1-扩展运算符：" class="headerlink" title="1) 扩展运算符：..."></a>1) 扩展运算符：<code>...</code></h6><p><code>...</code>可以把数组中的每一项展开</p>
<p>代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合并两个数组</span></span><br><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr3 = [...arr1, ...arr2];</span><br><span class="line"><span class="built_in">console</span>.log(arr3); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// 把数组展开作为参数，可以替代 apply</span></span><br><span class="line"><span class="comment">// 求数组的最大值</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">99</span>, <span class="number">10</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...arr); <span class="comment">// 等同于 Math.max(6, 99, 10, 1);</span></span><br></pre></td></tr></table></figure>

<h6 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2) Array.from()"></a>2) <code>Array.from()</code></h6><p>把伪数组转成数组</p>
<ul>
<li>伪数组必须有length属性，如果没有将返回一个空数组</li>
<li>转换后的数组长度，是根据伪数组的length决定的</li>
</ul>
<p>代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fakeArr = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Array</span>.from(fakeArr);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"><span class="comment">// 转数组的对象必须有length值，因为得到的数组的成员个数是length指定的个数</span></span><br><span class="line"><span class="comment">// 上例中，如果length为2，则得到的数组为 ['a', 'b']</span></span><br></pre></td></tr></table></figure>

<h6 id="3-find-方法和-findIndex-方法"><a href="#3-find-方法和-findIndex-方法" class="headerlink" title="3) find() 方法和 findIndex() 方法"></a>3) find() 方法和 findIndex() 方法</h6><ul>
<li>find()：用于查找数组中的值</li>
<li>findIndex()：用于查找数组的下标，用法与find一样</li>
</ul>
<p>代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">-4</span>, <span class="number">6</span>].find(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">//表示数组的每个值</span></span><br><span class="line">    <span class="built_in">console</span>.log(index); <span class="comment">//表示数组的每个下标</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr); <span class="comment">//表示整个数组</span></span><br><span class="line">    <span class="comment">//如果需要查找，要用到return 条件；</span></span><br><span class="line">    <span class="keyword">return</span> item &lt; <span class="number">0</span>; <span class="comment">//find方法会返回第一个满足条件的值，-1</span></span><br><span class="line">    <span class="comment">//如果是findIndex方法，会返回第一个满足条件的值的下标，2</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>find</strong> 找到数组中第一个满足条件的成员并<strong>返回该成员</strong>，如果找不到返回<strong>undefined</strong>。</li>
<li><strong>findIndex</strong> 找到数组中第一个满足条件的成员并<strong>返回该成员的索引</strong>，如果找不到返回 <strong>-1</strong>。</li>
</ul>
<h6 id="4-includes-方法"><a href="#4-includes-方法" class="headerlink" title="4) includes()方法"></a>4) includes()方法</h6><ul>
<li>判断数组是否包含某个值，返回 true / false</li>
<li>参数1，必须，表示查找的内容</li>
<li>参数2，可选，表示开始查找的位置，0表示开头的位置</li>
</ul>
<p>代码举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">4</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">4</span>, <span class="number">2</span>)); <span class="comment">// false， 从2的位置开始查，所以没有找到4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">5</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h6 id="5-includes-startsWith-endsWith"><a href="#5-includes-startsWith-endsWith" class="headerlink" title="5) includes(), startsWith(), endsWith()"></a>5) includes(), startsWith(), endsWith()</h6><ul>
<li><code>includes(str, [position])</code>       返回布尔值，表示是否找到了参数字符串</li>
<li><code>startsWidth(str, [position])</code>         返回布尔值，表示参数字符串是否在原字符串的头部或指定位置</li>
<li><code>endsWith(str, [position])</code>            返回布尔值，表示参数字符串是否在原字符串的尾部或指定位置。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>.includes(<span class="string">'e'</span>, <span class="number">2</span>)); <span class="comment">// false 从位置2开始查找e，没有找到</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>.includes(<span class="string">'e'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>.startsWith(<span class="string">'h'</span>)); <span class="comment">// 未指定位置，看开头是否是h，返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>.startsWith(<span class="string">'l'</span>, <span class="number">2</span>)); <span class="comment">// 指定位置的字符是l，返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>.endsWith(<span class="string">'d'</span>)); <span class="comment">// 未指定位置，结尾是d，返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>.endsWith(<span class="string">'r'</span>, <span class="number">9</span>)); <span class="comment">// 指定位置的字符是r，返回true</span></span><br></pre></td></tr></table></figure>

<h6 id="6-repeat-方法"><a href="#6-repeat-方法" class="headerlink" title="6) repeat()方法"></a>6) repeat()方法</h6><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="string">'&lt;li&gt;itheima&lt;/li&gt;'</span>;</span><br><span class="line">html = html.repeat(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h5 id="（五）新增对象Set"><a href="#（五）新增对象Set" class="headerlink" title="（五）新增对象Set"></a>（五）新增对象Set</h5><p>数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br> <code>Set</code>本身是一个构造函数，用来生成 Set 数据结构。<br> Set的特点就是该对象里面的成员不会有重复。</p>
<p><strong>1) 基本使用：</strong><br> <code>let set = new Set();</code> 得到一个空的Set对象。</p>
<p><strong>2) Set的成员</strong></p>
<ul>
<li><code>size</code>：属性，获取 <code>set</code> 中成员的个数，相当于数组中的 <code>length</code></li>
<li><code>add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">//调用<span class="keyword">set</span>对象内置的add方法，想<span class="keyword">set</span>中添加数据。</span><br><span class="line"><span class="keyword">set</span>.add(3);</span><br><span class="line"><span class="keyword">set</span>.add(8);</span><br><span class="line"><span class="keyword">set</span>.add(9);</span><br><span class="line"><span class="keyword">set</span>.add(3); //添加失败但不报错，<span class="keyword">set</span>中的成员不能重复</span><br><span class="line">console.log(<span class="keyword">set</span>); // &#123;<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.size); //3</span><br></pre></td></tr></table></figure>

<p>初始化Set的时候，也可以为其传入数组或字符串，得到的Set对象中的成员不会有重复。根据这个特点可以完成数组或字符串去重。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set([4, 8, 9, 5, 4, 8, 4, 2]);</span><br><span class="line">console.log(<span class="keyword">set</span>); //Set(5) &#123;<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [...set]; <span class="comment">//将set中的每个值展开，然后放到数组中</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//(5) [4, 8, 9, 5, 2]</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">'abcdacbdcbac'</span>); </span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">//Set(4) &#123;"a", "b", "c", "d"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log([...str].join(<span class="string">''</span>)); <span class="comment">//abcd</span></span><br></pre></td></tr></table></figure>

<p><font color="red">注：</font>转载于：<a href="https://www.jianshu.com/p/0120580f39aa" target="_blank" rel="noopener">https://www.jianshu.com/p/0120580f39aa</a></p>
<hr>
<h4 id="8-flex布局中align-items-和align-content的区别："><a href="#8-flex布局中align-items-和align-content的区别：" class="headerlink" title="8. flex布局中align-items 和align-content的区别："></a>8. <font color="#00AFF0"><strong>flex布局中align-items 和align-content的区别：</strong></font></h4><p>参考资料：<a href="http://stackoverflow.com/questions/31250174/css-flexbox-difference-between-align-items-and-align-content" target="_blank" rel="noopener">http://stackoverflow.com/questions/31250174/css-flexbox-difference-between-align-items-and-align-content</a></p>
<p>看了很多翻译的技术文档，这一块都讲得模糊不清，看到<code>stackoverflow</code>上有人提问后的回答觉得十分清晰，特来分享，有不当之处欢迎指正。<br><strong><code>align-items</code></strong></p>
<blockquote>
<p>The align-items property applies to all flex containers, and sets the<br>default alignment of the flex items along the cross axis of each flex<br>line.</p>
</blockquote>
<p><em>align-items属性适用于所有的flex容器，它是用来设置每个flex元素在交叉轴上的默认对齐方式。</em><br>还有一位回答者的回答也很好，如下</p>
<blockquote>
<p>align-items has the same functionality as align-content but the difference is that it works to center every single-line container instead of centering the whole container.</p>
</blockquote>
<p><em>align-items和align-content有相同的功能，不过不同点是它是用来让每一个单行的容器居中而不是让整个容器居中。</em></p>
<p>如下图<br><img src="https://www.w3.org/TR/css-flexbox-1/images/flex-align.svg" alt="这里写图片描述"></p>
<p><strong><code>align-content</code></strong></p>
<blockquote>
<p>The align-content property only applies to multi-line flex containers, and aligns the flex lines within the flex container when there is extra space in the cross-axis.</p>
</blockquote>
<p><em>align-content属性只适用于<strong>多行</strong>的flex容器，并且当交叉轴上有多余空间使flex容器内的flex线对齐。</em><br>感觉这样翻译了之后还是略微有些抽象，不过有一个重点就是<strong>多行</strong>，<br>下面我们来写一个小的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"child-1"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"child-2"</span>&gt;					</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div class="child-2"&gt;					</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>html结构如上。<br>如果child-1的<code>width</code>设置为<code>100px</code>,child-2的<code>width</code>设置为<code>30px</code>,这样child-2会排列在一排上，具体的css如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">    margin:<span class="number">0</span>px;</span><br><span class="line">    padding: <span class="number">0</span>px;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">    border: 1px solid #0f0f0f;</span><br><span class="line">&#125;</span><br><span class="line">.child<span class="number">-1</span>&#123;</span><br><span class="line">    margin: <span class="number">30</span>px auto;</span><br><span class="line">    display: flex;</span><br><span class="line">    width: <span class="number">100</span>px;</span><br><span class="line">    height: <span class="number">60</span>px;</span><br><span class="line">    justify-content: space-around;</span><br><span class="line">    align-content: center;</span><br><span class="line">&#125;</span><br><span class="line">.child<span class="number">-2</span>&#123;</span><br><span class="line">    width: <span class="number">30</span>px;</span><br><span class="line">    height: <span class="number">20</span>px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终的结果如下图<br><img src="https://img-blog.csdn.net/20160529165707931" alt="这里写图片描述"></p>
<p>所以对于只有一行的flex元素，align-content是没有效果的，如果<code>.child-1</code>改用<code>align-items:center;</code>则会达到预期的效果，如下图<br><img src="https://img-blog.csdn.net/20160529170816060" alt="这里写图片描述"></p>
<p>但如果变成多行容器<br>使用<code>align-items</code>时效果如下<br><img src="https://img-blog.csdn.net/20160529172314363" alt="这里写图片描述"><br>使用<code>align-content</code>效果如下<br><img src="https://img-blog.csdn.net/20160529172339941" alt="这里写图片描述"></p>
<p><font color="red">注：</font>转载于：<a href="https://blog.csdn.net/sinat_27088253/article/details/51532992" target="_blank" rel="noopener">https://blog.csdn.net/sinat_27088253/article/details/51532992</a></p>
<hr>
<h4 id="9-vue中computed和watch的区别："><a href="#9-vue中computed和watch的区别：" class="headerlink" title="9. vue中computed和watch的区别："></a>9. <font color="#00AFF0"><strong>vue中computed和watch的区别：</strong></font></h4><p><strong>计算属性computed :</strong></p>
<p>1) 支持缓存，只有依赖数据发生改变，才会重新进行计算<br>2) 不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p>
<p>3) computed属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p>
<p>4) 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p>
<p>5) 如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的属性都有一个get和一个set方法，当数据变化时,调用set方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"firstName"</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"lastName"</span>&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> v-model=<span class="string">"fullName"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="node_modules/</span>vue/dist/vue.js<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">  let vm = new Vue(&#123;</span></span><br><span class="line">    el: "#app",</span><br><span class="line">    data: &#123;</span><br><span class="line">      firstName: <span class="string">"尚”,</span></span><br><span class="line"><span class="string">      lastName: "</span>晓林<span class="string">",</span></span><br><span class="line"><span class="string">      ful1Name: "</span><span class="string">"</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    computed: &#123;</span></span><br><span class="line"><span class="string">      fullName() &#123;</span></span><br><span class="line"><span class="string">        return this.firstName + "</span><span class="string">" + this.lastName</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>侦听属性watch：</strong></p>
<p>1) 不支持缓存，数据变，直接会触发相应的操作;<br>2) watch支持异步;<br>3) 监听的函数接收两个参数，第一个参数是最新的值;第二个参数是输入之前的值;<br>4) 当一个属性发生变化时，需要执行对应的操作，一对多;<br>5) 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数</p>
<blockquote>
<p>immediate：组件加载立即触发回调函数执行；</p>
<p>deep：深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变,注意监听数组的变动不需要这么做。注意: deep无法监听到数组的变动<br>和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123; <span class="comment">// 监听属性: - 定是存在的属性:是data中的属性:</span></span><br><span class="line">  a(newVal, oldVal) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"密码太短"</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newVal.length &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = <span class="string">"密码太长"</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.msg = <span class="string">''</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听的对象也可以写成字符串的形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=<span class="string">"div1"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> V-model=<span class="string">"user_info.name"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">let</span> vm=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">' #div1'</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      user_info: &#123;</span><br><span class="line">        name: <span class="string">'blue'</span>,</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      <span class="string">'user_info.name'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'name变了'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。这是和computed最大的区别，请勿滥用。</p>
<p><font color="red">注：</font>转载于：<a href="https://blog.csdn.net/nanzhuhe/article/details/105017015" target="_blank" rel="noopener">https://blog.csdn.net/nanzhuhe/article/details/105017015</a></p>
<hr>
<h4 id="10-关于Vue中computed-和-watch-的区别："><a href="#10-关于Vue中computed-和-watch-的区别：" class="headerlink" title="10. 关于Vue中computed-和-watch-的区别："></a>10. <font color="#00AFF0"><strong>关于Vue中computed-和-watch-的区别：</strong></font></h4><p>前言</p>
<p>在vue的我的项目中，咱们时常会须要对data的扭转做出解决，这时候就须要用到watch和computed这两个属性，既然都是数值扭转触发扭转的属性，他们之间又有什么异同呢？</p>
<p><strong>computed</strong></p>
<ul>
<li>computed 是计算属性，它会依据你所依赖的数据动态显示新的计算结果。</li>
<li>计算属性将被退出到 Vue 实例中。所有 getter 和 setter 的 this 上下文主动地绑定为 Vue 实例</li>
<li>通过计算出来的属性不须要调用间接能够在 DOM 里应用</li>
</ul>
<p>例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'red'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string"> &lt;div&gt; &lt;p&gt;我是原始值: "&#123;&#123; message &#125;&#125;"&lt;/p&gt; &lt;p&gt;我是计算属性的值: "&#123;&#123; computedMessage&#125;&#125;"&lt;/p&gt; // computed 在 DOM 里间接应用不须要调用 &lt;/div&gt; `</span>,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter     computedMessage: function () &#123;</span></span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例       return this.message.split('').reverse().join('')</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>后果：<br>我是原始值: “red”<br>我是计算属性的值: “der”</p>
<p>如果不应用计算属性，那么 message.split(”).reverse().join(”) 就会间接写到 template 里，那么在模版中放入太多申明式的逻辑会让模板自身过重，尤其当在页面中应用大量简单的逻辑表达式解决数据时，会对页面的可维护性造成很大的影响</p>
<p>而且计算属性如果依赖不变的话，它就会变成缓存，computed 的值就不会从新计算</p>
<p>所以，如果数据要通过简单逻辑来得出后果，那么就举荐应用计算属性</p>
<p><strong>watch</strong></p>
<ul>
<li>一个对象，键是 data 对应的数据，值是对应的回调函数。值也能够是办法名，或者蕴含选项的对象，当 data 的数据发生变化时，就会产生一个回调，他有两个参数，一个 val （批改后的 data 数据），一个 oldVal（原来的 data 数据）</li>
</ul>
<p>Vue 实例将会在实例化时调用<code>$watch()</code>，遍历 watch 对象的每一个属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;jav</span><br><span class="line">    n: <span class="number">0</span>,</span><br><span class="line">    obj: &#123;</span><br><span class="line">      a: <span class="string">"a"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string"> &lt;div&gt; &lt;button @click="n += 1"&gt;n+1&lt;/button&gt; &lt;button @click="obj.a += 'hi'"&gt;obj.a + 'hi'&lt;/button&gt; &lt;button @click="obj = &#123;a:'a'&#125;"&gt;obj = 新对象&lt;/button&gt; &lt;/div&gt; `</span>,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    n() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"n 变了"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    obj:&#123;</span><br><span class="line">      handler: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"obj 变了"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">      deep: <span class="literal">true</span> <span class="comment">// 该属性设定在任何被侦听的对象的 property 扭转时都要执行 handler 的回调，不管其被嵌套多深     &#125;,</span></span><br><span class="line">    <span class="string">"obj.a"</span>:&#123;</span><br><span class="line">      handler: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"obj.a 变了"</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">      immediate: <span class="literal">true</span> <span class="comment">// 该属性设定该回调将会在侦听开始之后被立刻调用     &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>);</span><br></pre></td></tr></table></figure>

<p>留神：不应该应用箭头函数来定义 watcher 函数，因为箭头函数没有 this，它的 this 会继承它的父级函数，然而它的父级函数是 window，导致箭头函数的 this 指向 window，而不是 Vue 实例</p>
<ul>
<li>deep 管制是否要看这个对象外面的属性变动</li>
<li>immediate 管制是否在第一次渲染是执行这个函数</li>
<li>vm.$watch(‘data属性名’, fn, {deep: .., immediate: ..})</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">"n"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">val, newVal</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"n 变了"</span>);</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">immediate</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>两者区别</strong></p>
<p>相同点：</p>
<p>两者都是察看页面数据变动的。</p>
<p>不同点：</p>
<ul>
<li>computed 只有当依赖的数据变动时才会计算, 会缓存数据。</li>
<li>watch 每次都须要执行函数。watch 更实用于数据变动时的异步操作</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>如果一个数据须要通过简单计算就用 computed</li>
<li>如果一个数据须要被监听并且对数据做一些操作就用 watch</li>
</ul>
<p><font color="red">注：</font>转载于：<a href="https://lequ7.com/guan-yu-javascriptvue-zhong-computed-he-watch-de-qu-bie.html" target="_blank" rel="noopener">https://lequ7.com/guan-yu-javascriptvue-zhong-computed-he-watch-de-qu-bie.html</a></p>
<hr>
<h4 id="11-vue中watch-computed-mehtod执行顺序："><a href="#11-vue中watch-computed-mehtod执行顺序：" class="headerlink" title="11. vue中watch,computed,mehtod执行顺序："></a>11. <font color="#00AFF0"><strong>vue中watch,computed,mehtod执行顺序：</strong></font></h4><p>在vue中数据存在的方式有：data , props , computed </p>
<p>由于vue的双向数据绑定，自动更新数据的机制，在数据变化后，对此数据依赖 的所有数据，watch事件都会被更新、触发。所以，只有数据本身变化了，依赖项才会改变。</p>
<blockquote>
<p>computed：只有当computed 属性被使用后，才会执行computed的代码，若组件中未被使用，computed代码不会执行。</p>
</blockquote>
<p>执行顺序：</p>
<blockquote>
<p>页面加载时：</p>
<p>onload: watch(immediate：true) –&gt; computed –&gt; watch(默认computed：false)</p>
<p>交互改变数据时：</p>
<p>event : watch –&gt; computed –&gt; method </p>
</blockquote>
<p><font color="red">注：</font>watch中的数据设置immediate：true时，在组件加载时将立刻执行（v-modal双向绑定的数据值都已更新，才会执行watch方法）。</p>
<p>​      另外，computed数据在method中和在html中被使用时，代码被执行的顺序稍有不同。通过打断点发现，当computed在method中被使用时，代码首先执行值computed被引用处，然后继续执行computed代码，其实，最后的结果都是一样，在method中拿到的computed数据都是更新过的。ps:尽量少用watch，不然数据流不清晰</p>
<p>ele组件的执行顺序：（绑定的都是change事件）</p>
<blockquote>
<p>radio：v-model –&gt; watch–&gt; method –&gt; computed<br>radioGroup：v-model –&gt; watch–&gt; method –&gt; computed<br>checkbox： v-model –&gt; method –&gt; computed –&gt; watch<br>checkboxGroup： v-model –&gt; watch  –&gt; method  –&gt; computed </p>
</blockquote>
<p><font color="red">注：</font>转载于：<a href="https://www.lmlphp.com/user/1088/article/item/14716/" target="_blank" rel="noopener">https://www.lmlphp.com/user/1088/article/item/14716/</a></p>
<hr>
<h4 id="12-Event-Loop（一）"><a href="#12-Event-Loop（一）" class="headerlink" title="12. Event Loop（一）"></a>12. <font color="#00AAF0">Event Loop（一）</font></h4><p>Event Loop 是一个很重要的概念，指的是计算机系统的一种运行机制。</p>
<p>JavaScript语言就采用这种机制，来解决单线程运行带来的一些问题。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201310/2013102001.png" alt="Event Loop"></p>
<p>本文参考C. Aaron Cois的<a href="https://www.udemy.com/lectures/understanding-the-nodejs-event-loop-91298" target="_blank" rel="noopener">《Understanding The Node.js Event Loop》</a>，解释什么是Event Loop，以及它与JavaScript语言的单线程模型有何关系。</p>
<p>想要理解Event Loop，就要从程序的运行模式讲起。运行以后的程序叫做<a href="https://zh.wikipedia.org/wiki/进程" target="_blank" rel="noopener">“进程”</a>（process），一般情况下，一个进程一次只能执行一个任务。</p>
<p>如果有很多任务需要执行，不外乎三种解决方法。</p>
<blockquote>
<p><strong>（1）排队。</strong>因为一个进程一次只能执行一个任务，只好等前面的任务执行完了，再执行后面的任务。</p>
<p><strong>（2）新建进程。</strong>使用fork命令，为每个任务新建一个进程。</p>
<p><strong>（3）新建线程。</strong>因为进程太耗费资源，所以如今的程序往往允许一个进程包含多个线程，由线程去完成任务。（进程和线程的详细解释，请看<a href="https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">这里</a>。）</p>
</blockquote>
<p>以JavaScript语言为例，它是一种单线程语言，所有任务都在一个线程上完成，即采用上面的第一种方法。一旦遇到大量任务或者遇到一个耗时的任务，网页就会出现”假死”，因为JavaScript停不下来，也就无法响应用户的行为。</p>
<p>你也许会问，JavaScript为什么是单线程，难道不能实现为多线程吗？</p>
<p>这跟历史有关系。JavaScript从诞生起就是单线程。原因大概是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。后来就约定俗成，JavaScript为一种单线程语言。（Worker API可以实现多线程，但是JavaScript本身始终是单线程的。）</p>
<p>如果某个任务很耗时，比如涉及很多I/O（输入/输出）操作，那么线程的运行大概是下面的样子。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201310/2013102002.png" alt="synchronous mode"></p>
<p>上图的绿色部分是程序的运行时间，红色部分是等待时间。可以看到，由于I/O操作很慢，所以这个线程的大部分运行时间都在空等I/O操作的返回结果。这种运行方式称为”同步模式”（synchronous I/O）或”堵塞模式”（blocking I/O）。</p>
<p>如果采用多线程，同时运行多个任务，那很可能就是下面这样。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201310/2013102003.png" alt="synchronous mode"></p>
<p>上图表明，多线程不仅占用多倍的系统资源，也闲置多倍的资源，这显然不合理。</p>
<p>Event Loop就是为了解决这个问题而提出的。<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">Wikipedia</a>这样定义：</p>
<blockquote>
<p>“<strong>Event Loop是一个程序结构，用于等待和发送消息和事件。</strong>（a programming construct that waits for and dispatches events or messages in a program.）”</p>
</blockquote>
<p>简单说，就是在程序中设置两个线程：一个负责程序本身的运行，称为”主线程”；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为”Event Loop线程”（可以译为”消息线程”）。</p>
<p><img src="https://www.ruanyifeng.com/blogimg/asset/201310/2013102004.png" alt="asynchronous mode"></p>
<p>上图主线程的绿色部分，还是表示运行时间，而橙色部分表示空闲时间。每当遇到I/O的时候，主线程就让Event Loop线程去通知相应的I/O程序，然后接着往后运行，所以不存在红色的等待时间。等到I/O程序完成操作，Event Loop线程再把结果返回主线程。主线程就调用事先设定的回调函数，完成整个任务。</p>
<p>可以看到，由于多出了橙色的空闲时间，所以主线程得以运行更多的任务，这就提高了效率。这种运行方式称为”<a href="https://en.wikipedia.org/wiki/Asynchronous_I/O" target="_blank" rel="noopener">异步模式</a>“（asynchronous I/O）或”非堵塞模式”（non-blocking mode）。</p>
<p>这正是JavaScript语言的运行方式。单线程模型虽然对JavaScript构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果部署得好，JavaScript程序是不会出现堵塞的，这就是为什么node.js平台可以用很少的资源，应付大流量访问的原因。</p>
<p><font color="red">注：</font>转载于：(阮一峰) <a href="https://www.ruanyifeng.com/blog/2013/10/event_loop.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2013/10/event_loop.html</a></p>
<hr>
<h4 id="13-Event-Loop（二）"><a href="#13-Event-Loop（二）" class="headerlink" title="13. Event Loop（二）"></a>13. <font color="#00AAF0">Event Loop（二）</font></h4><p><strong>前言</strong></p>
<p><code>Event Loop</code>即事件循环，是指浏览器或<code>Node</code>的一种解决<code>javaScript</code>单线程运行时不会阻塞的一种机制，也就是我们经常使用<strong>异步</strong>的原理。</p>
<p><strong>为啥要弄懂Event Loop</strong></p>
<ul>
<li>是要增加自己技术的深度，也就是懂得<code>JavaScript</code>的运行机制。</li>
<li>现在在前端领域各种技术层出不穷，掌握底层原理，可以让自己以不变，应万变。</li>
<li>应对各大互联网公司的面试，懂其原理，题目任其发挥。</li>
</ul>
<p><strong>堆，栈、队列</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-2b6bb774a0b2125208638776184b9482_720w.jpg" alt="img"></p>
<p><strong>堆（Heap）</strong></p>
<p><strong>堆</strong>是一种数据结构，是利用完全二叉树维护的一组数据，<strong>堆</strong>分为两种，一种为最大<strong>堆</strong>，一种为<strong>最小堆</strong>，将根节点<strong>最大</strong>的<strong>堆</strong>叫做<strong>最大堆</strong>或<strong>大根堆</strong>，根节点<strong>最小</strong>的<strong>堆</strong>叫做<strong>最小堆</strong>或<strong>小根堆</strong>。</p>
<p><strong>堆</strong>是<strong>线性数据结构</strong>，相当于<strong>一维数组</strong>，有唯一后继。</p>
<p>如最大堆</p>
<p><img src="https://pic4.zhimg.com/80/v2-ad50ceadc24face630fa16df2c55a337_720w.jpg" alt="img"></p>
<p><strong>栈（Stack）</strong></p>
<p><strong>栈</strong>在计算机科学中是限定仅在<strong>表尾</strong>进行<strong>插入</strong>或<strong>删除</strong>操作的线性表。<strong>栈</strong>是一种数据结构，它按照<strong>后进先出</strong>的原则存储数据，<strong>先进入</strong>的数据被压入<strong>栈底</strong>，<strong>最后的数据</strong>在<strong>栈顶</strong>，需要读数据的时候从<strong>栈顶</strong>开始<strong>弹出数据</strong>。</p>
<p><strong>栈</strong>是只能在<strong>某一端插入</strong>和<strong>删除</strong>的<strong>特殊线性表</strong>。</p>
<p><img src="https://pic2.zhimg.com/80/v2-5fc7ba6275e5f2ab5cdb3b7cb97e223d_720w.jpg" alt="img"></p>
<p><strong>队列（Queue）</strong></p>
<p>特殊之处在于它只允许在表的前端（<code>front</code>）进行<strong>删除</strong>操作，而在表的后端（<code>rear</code>）进行<strong>插入</strong>操作，和<strong>栈</strong>一样，<strong>队列</strong>是一种操作受限制的线性表。</p>
<p>进行<strong>插入</strong>操作的端称为<strong>队尾</strong>，进行<strong>删除</strong>操作的端称为<strong>队头</strong>。 队列中没有元素时，称为<strong>空队列</strong>。</p>
<p><strong>队列</strong>的数据元素又称为<strong>队列元素</strong>。在队列中插入一个队列元素称为<strong>入队</strong>，从<strong>队列</strong>中<strong>删除</strong>一个队列元素称为<strong>出队</strong>。因为队列<strong>只允许</strong>在一端<strong>插入</strong>，在另一端<strong>删除</strong>，所以只有<strong>最早</strong>进入<strong>队列</strong>的元素<strong>才能最先从队列中</strong>删除，故队列又称为<strong>先进先出</strong>（<code>FIFO—first in first out</code>）</p>
<p><img src="https://pic3.zhimg.com/80/v2-739f0f7462fd7aaac444a6d2b047f696_720w.jpg" alt="img"></p>
<p><strong>Event Loop</strong></p>
<p>在<code>JavaScript</code>中，任务被分为两种，一种宏任务（<code>MacroTask</code>）也叫<code>Task</code>，一种叫微任务（<code>MicroTask</code>）。</p>
<p><strong>MacroTask（宏任务）</strong></p>
<ul>
<li><code>script</code>全部代码、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（浏览器暂时不支持，只有IE10支持，具体可见<code>MDN</code>）、<code>I/O</code>、<code>UI Rendering</code>。</li>
</ul>
<p><strong>MicroTask（微任务）</strong></p>
<ul>
<li><code>Process.nextTick（Node独有）</code>、<code>Promise</code>、<code>Object.observe(废弃)</code>、<code>MutationObserver</code>（具体使用方式查看<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%3A%2F%2Fjavascript.ruanyifeng.com%2Fdom%2Fmutationobserver.html">这里</a>）</li>
</ul>
<p><strong>浏览器中的Event Loop</strong></p>
<p><code>Javascript</code> 有一个 <code>main thread</code> 主线程和 <code>call-stack</code> 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>
<p><strong>JS调用栈</strong></p>
<p>JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p>
<p><strong>同步任务和异步任务</strong></p>
<p><code>Javascript</code>单线程任务被分为<strong>同步任务</strong>和<strong>异步任务</strong>，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。</p>
<p><img src="https://pic4.zhimg.com/80/v2-55c58a901cf835e5e308e4360694505f_720w.jpg" alt="img"></p>
<p>任务队列<code>Task Queue</code>，即队列，是一种先进先出的一种数据结构。</p>
<p><img src="https://pic3.zhimg.com/80/v2-971a09fea16fff72db03d498245bc892_720w.jpg" alt="img"></p>
<p><strong>事件循环的进程模型</strong></p>
<ul>
<li>选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即<code>null</code>，则执行跳转到微任务（<code>MicroTask</code>）的执行步骤。</li>
<li>将事件循环中的任务设置为已选择任务。</li>
<li>执行任务。</li>
<li>将事件循环中当前运行任务设置为null。</li>
<li>将已经运行完成的任务从任务队列中删除。</li>
<li>microtasks步骤：进入microtask检查点。</li>
<li>更新界面渲染。</li>
<li>返回第一步。</li>
</ul>
<p><strong>执行进入microtask检查点时，用户代理会执行以下步骤：</strong></p>
<ul>
<li>设置microtask检查点标志为true。</li>
<li>当事件循环<code>microtask</code>执行不为空时：选择一个最先进入的<code>microtask</code>队列的<code>microtask</code>，将事件循环的<code>microtask</code>设置为已选择的<code>microtask</code>，运行<code>microtask</code>，将已经执行完成的<code>microtask</code>为<code>null</code>，移出<code>microtask</code>中的<code>microtask</code>。</li>
<li>清理IndexDB事务</li>
<li>设置进入microtask检查点的标志为false。</li>
</ul>
<p>上述可能不太好理解，下图是我做的一张图片。</p>
<p><img src="https://pic3.zhimg.com/v2-bd2aa27705ca757fc676a37505a4f992_b.jpg" alt="img"></p>
<p>执行栈在执行完<strong>同步任务</strong>后，查看<strong>执行栈</strong>是否为空，如果执行栈为空，就会去执行<code>Task</code>（宏任务），每次<strong>宏任务</strong>执行完毕后，检查<strong>微任务</strong>(<code>microTask</code>)队列是否为空，如果不为空的话，会按照<strong>先入先</strong>出的规则全部执行完<strong>微任务</strong>(<code>microTask</code>)后，设置<strong>微任务</strong>(<code>microTask</code>)队列为<code>null</code>，然后再执行<strong>宏任务</strong>，如此循环。</p>
<p><strong>举个例子</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure>

<p>首先我们划分几个分类：</p>
<p><strong>第一次执行：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks：run script、 setTimeout callback</span><br><span class="line"></span><br><span class="line">Microtasks：<span class="built_in">Promise</span> then	</span><br><span class="line"></span><br><span class="line">JS stack: script	</span><br><span class="line">Log: script start、script end。</span><br></pre></td></tr></table></figure>

<p>执行同步代码，将宏任务（<code>Tasks</code>）和微任务(<code>Microtasks</code>)划分到各自队列中。</p>
<p><strong>第二次执行：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks：run script、 setTimeout callback</span><br><span class="line"></span><br><span class="line">Microtasks：Promise2 then	</span><br><span class="line"></span><br><span class="line">JS stack: Promise2 callback	</span><br><span class="line">Log: script start、script end、promise1、promise2</span><br></pre></td></tr></table></figure>

<p>执行宏任务后，检测到微任务(<code>Microtasks</code>)队列中不为空，执行<code>Promise1</code>，执行完成<code>Promise1</code>后，调用<code>Promise2.then</code>，放入微任务(<code>Microtasks</code>)队列中，再执行<code>Promise2.then</code>。</p>
<p><strong>第三次执行：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks：setTimeout callback</span><br><span class="line"></span><br><span class="line">Microtasks：	</span><br><span class="line"></span><br><span class="line">JS stack: setTimeout callback</span><br><span class="line">Log: script start、script end、promise1、promise2、setTimeout</span><br></pre></td></tr></table></figure>

<p>当微任务(<code>Microtasks</code>)队列中为空时，执行宏任务（<code>Tasks</code>），执行<code>setTimeout callback</code>，打印日志。</p>
<p><strong>第四次执行：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tasks：setTimeout callback</span><br><span class="line"></span><br><span class="line">Microtasks：	</span><br><span class="line"></span><br><span class="line">JS stack: </span><br><span class="line">Log: script start、script end、promise1、promise2、setTimeout</span><br></pre></td></tr></table></figure>

<p>清空<strong>Tasks</strong>队列和<code>JS stack</code>。</p>
<p>以上执行帧动画可以查看<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F">Tasks, microtasks, queues and schedules</a><br>或许这张图也更好理解些。</p>
<p><img src="https://pic2.zhimg.com/v2-d1ca0d6b13501044a5f74c99becbcd3d_b.jpg" alt="img"></p>
<p><strong>再举个例子</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>) </span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>

<p>这里需要先理解<code>async/await</code>。<br><code>async/await</code> 在底层转换成了 <code>promise</code> 和 <code>then</code> 回调函数。<br>也就是说，这是 <code>promise</code> 的语法糖。<br>每次我们使用 <code>await</code>, 解释器都创建一个 <code>promise</code> 对象，然后把剩下的 <code>async</code> 函数中的操作放到 <code>then</code> 回调函数中。<br><code>async/await</code> 的实现，离不开 <code>Promise</code>。从字面意思来理解，<code>async</code> 是“异步”的简写，而 <code>await</code> 是 <code>async wait</code> 的简写可以认为是等待异步方法执行完成。</p>
<p><strong>关于73以下版本和73版本的区别</strong></p>
<ul>
<li>在73版本以下，先执行<code>promise1</code>和<code>promise2</code>，再执行<code>async1</code>。</li>
<li>在73版本，先执行<code>async1</code>再执行<code>promise1</code>和<code>promise2</code>。</li>
</ul>
<p><strong>主要原因是因为在谷歌(金丝雀)73版本中更改了规范，如下图所示：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-8f08aa1f5e0d5dec5b861e0c006dedc8_720w.jpg" alt="img"></p>
<ul>
<li>区别在于<code>RESOLVE(thenable)</code>和之间的区别<code>Promise.resolve(thenable)</code>。</li>
</ul>
<p><strong>在73以下版本中</strong></p>
<ul>
<li>首先，传递给 <code>await</code> 的值被包裹在一个 <code>Promise</code> 中。然后，处理程序附加到这个包装的 <code>Promise</code>，以便在 <code>Promise</code> 变为 <code>fulfilled</code> 后恢复该函数，并且暂停执行异步函数，一旦 <code>promise</code> 变为 <code>fulfilled</code>，恢复异步函数的执行。</li>
<li>每个 <code>await</code> 引擎必须创建两个额外的 Promise（即使右侧已经是一个 <code>Promise</code>）并且它需要至少三个 <code>microtask</code> 队列 <code>ticks</code>（<code>tick</code>为系统的相对时间单位，也被称为系统的时基，来源于定时器的周期性中断（输出脉冲），一次中断表示一个<code>tick</code>，也被称做一个“时钟滴答”、时标。）。</li>
</ul>
<p><strong>引用贺老师知乎上的一个例子</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> p</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化理解为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> RESOLVE(p).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'ok'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 <code>RESOLVE(p)</code> 对于 <code>p</code> 为 <code>promise</code> 直接返回 <code>p</code> 的话，那么 <code>p</code>的 <code>then</code> 方法就会被马上调用，其回调就立即进入 <code>job</code> 队列。</li>
<li>而如果 RESOLVE(p) 严格按照标准，应该是产生一个新的 promise，尽管该 promise确定会 resolve 为 p，但这个过程本身是异步的，也就是现在进入 job 队列的是新 promise 的 resolve过程，所以该 promise 的 then 不会被立即调用，而要等到当前 job 队列执行到前述 resolve 过程才会被调用，然后其回调（也就是继续 await 之后的语句）才加入 job 队列，所以时序上就晚了。</li>
</ul>
<p><strong>谷歌（金丝雀）73版本中</strong></p>
<ul>
<li>使用对<code>PromiseResolve</code>的调用来更改<code>await</code>的语义，以减少在公共<code>awaitPromise</code>情况下的转换次数。</li>
<li>如果传递给 <code>await</code> 的值已经是一个 <code>Promise</code>，那么这种优化避免了再次创建 <code>Promise</code> 包装器，在这种情况下，我们从最少三个 <code>microtick</code> 到只有一个 <code>microtick</code>。</li>
</ul>
<p><strong>详细过程：</strong></p>
<p> <strong>73以下版本</strong></p>
<ul>
<li>首先，打印<code>script start</code>，调用<code>async1()</code>时，返回一个<code>Promise</code>，所以打印出来<code>async2 end</code>。</li>
<li>每个 <code>await</code>，会新产生一个<code>promise</code>,但这个过程本身是异步的，所以该<code>await</code>后面不会立即调用。</li>
<li>继续执行同步代码，打印<code>Promise</code>和<code>script end</code>，将<code>then</code>函数放入<strong>微任务</strong>队列中等待执行。</li>
<li>同步执行完成之后，检查<strong>微任务</strong>队列是否为<code>null</code>，然后按照先入先出规则，依次执行。</li>
<li>然后先执行打印<code>promise1</code>,此时<code>then</code>的回调函数返回<code>undefinde</code>，此时又有<code>then</code>的链式调用，又放入<strong>微任务</strong>队列中，再次打印<code>promise2</code>。</li>
<li>再回到<code>await</code>的位置执行返回的 <code>Promise</code> 的 <code>resolve</code> 函数，这又会把 <code>resolve</code> 丢到微任务队列中，打印<code>async1 end</code>。</li>
<li>当<strong>微任务</strong>队列为空时，执行宏任务,打印<code>setTimeout</code>。</li>
</ul>
<p><strong>谷歌（金丝雀73版本）</strong></p>
<ul>
<li>如果传递给 <code>await</code> 的值已经是一个 <code>Promise</code>，那么这种优化避免了再次创建 <code>Promise</code> 包装器，在这种情况下，我们从最少三个 <code>microtick</code> 到只有一个 <code>microtick</code>。</li>
<li>引擎不再需要为 <code>await</code> 创造 <code>throwaway Promise</code> - 在绝大部分时间。</li>
<li>现在 <code>promise</code> 指向了同一个 <code>Promise</code>，所以这个步骤什么也不需要做。然后引擎继续像以前一样，创建 <code>throwaway Promise</code>，安排 <code>PromiseReactionJob</code> 在 <code>microtask</code> 队列的下一个 <code>tick</code> 上恢复异步函数，暂停执行该函数，然后返回给调用者。</li>
</ul>
<p>具体详情查看（<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fv8.js.cn%2Fblog%2Ffast-async%2F">这里</a>）。</p>
<p><strong>NodeJS的Event Loop</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-309eac4093b71a02806c3648bf34021e_720w.jpg" alt="img"></p>
<p><code>Node</code>中的<code>Event Loop</code>是基于<code>libuv</code>实现的，而<code>libuv</code>是 <code>Node</code> 的新跨平台抽象层，libuv使用异步，事件驱动的编程方式，核心是提供<code>i/o</code>的事件循环和异步回调。libuv的<code>API</code>包含有时间，非阻塞的网络，异步文件操作，子进程等等。 <code>Event Loop</code>就是在<code>libuv</code>中实现的。</p>
<p><img src="https://pic3.zhimg.com/80/v2-69eca8db217343dd4ecf8b1bf2c255ca_720w.jpg" alt="img"></p>
<p><code>Node</code>的<code>Event loop</code>一共分为6个阶段，每个细节具体如下：</p>
<ul>
<li><code>timers</code>: 执行<code>setTimeout</code>和<code>setInterval</code>中到期的<code>callback</code>。</li>
<li><code>pending callback</code>: 上一轮循环中少数的<code>callback</code>会放在这一阶段执行。</li>
<li><code>idle, prepare</code>: 仅在内部使用。</li>
<li><code>poll</code>: 最重要的阶段，执行<code>pending callback</code>，在适当的情况下回阻塞在这个阶段。</li>
<li><code>check</code>: 执行<code>setImmediate</code>(<code>setImmediate()</code>是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行<code>setImmediate</code>指定的回调函数)的<code>callback</code>。</li>
<li><code>close callbacks</code>: 执行<code>close</code>事件的<code>callback</code>，例如<code>socket.on(&#39;close&#39;[,fn])</code>或者<code>http.server.on(&#39;close, fn)</code>。</li>
</ul>
<p><strong>具体细节如下：</strong></p>
<p>timers<br>执行<code>setTimeout</code>和<code>setInterval</code>中到期的<code>callback</code>，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行callback回调，但是由于<code>system</code>的调度可能会延时，达不到预期时间。<br>以下是官网文档解释的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Assume this takes 95ms to complete</span></span><br><span class="line">  fs.readFile(<span class="string">'/path/to/file'</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// do someAsyncOperation which takes 95 ms to complete</span></span><br><span class="line">someAsyncOperation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do something that will take 10ms...</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - startCallback &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当进入事件循环时，它有一个空队列（<code>fs.readFile()</code>尚未完成），因此定时器将等待剩余毫秒数，当到达95ms时，<code>fs.readFile()</code>完成读取文件并且其完成需要10毫秒的回调被添加到轮询队列并执行。<br>当回调结束时，队列中不再有回调，因此事件循环将看到已达到最快定时器的<strong>阈值</strong>，然后回到<strong>timers阶段</strong>以执行定时器的回调。<br>在此示例中，您将看到正在调度的计时器与正在执行的回调之间的总延迟将为105毫秒。</p>
<p><strong>以下是我测试时间：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-acaa19de3de2c22c212dc208f7649bef_720w.jpg" alt="img"></p>
<p><strong>pending callbacks</strong></p>
<p>此阶段执行某些系统操作（例如TCP错误类型）的回调。 例如，如果<code>TCP socket ECONNREFUSED</code>在尝试connect时receives，则某些* nix系统希望等待报告错误。 这将在<code>pending callbacks</code>阶段执行。</p>
<p><strong>poll</strong></p>
<p><strong>该poll阶段有两个主要功能：</strong></p>
<ul>
<li>执行<code>I/O</code>回调。</li>
<li>处理轮询队列中的事件。</li>
</ul>
<p><strong>当事件循环进入<code>poll</code>阶段并且在<code>timers</code>中没有可以执行定时器时，将发生以下两种情况之一</strong></p>
<ul>
<li>如果<code>poll</code>队列不为空，则事件循环将遍历其同步执行它们的<code>callback</code>队列，直到队列为空，或者达到<code>system-dependent</code>（系统相关限制）。</li>
</ul>
<p><strong>如果<code>poll</code>队列为空，则会发生以下两种情况之一</strong></p>
<ul>
<li>如果有<code>setImmediate()</code>回调需要执行，则会立即停止执行<code>poll</code>阶段并进入执行<code>check</code>阶段以执行回调。</li>
<li>如果没有<code>setImmediate()</code>回到需要执行，poll阶段将等待<code>callback</code>被添加到队列中，然后立即执行。</li>
</ul>
<p><strong>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</strong></p>
<p><strong>check</strong></p>
<p><strong>此阶段允许人员在poll阶段完成后立即执行回调。</strong><br>如果<code>poll</code>阶段闲置并且<code>script</code>已排队<code>setImmediate()</code>，则事件循环到达check阶段执行而不是继续等待。</p>
<p><code>setImmediate()</code>实际上是一个特殊的计时器，它在事件循环的一个单独阶段运行。它使用<code>libuv API</code>来调度在<code>poll</code>阶段完成后执行的回调。<br>通常，当代码被执行时，事件循环最终将达到<code>poll</code>阶段，它将等待传入连接，请求等。<br>但是，如果已经调度了回调<code>setImmediate()</code>，并且轮询阶段变为空闲，则它将结束并且到达<code>check</code>阶段，而不是等待<code>poll</code>事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>

<p>如果<code>node</code>版本为<code>v11.x</code>， 其结果与浏览器一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure>

<p>具体详情可以查看《<a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5c3e8d90f265da614274218a">又被node的eventloop坑了，这次是node的锅</a>》。</p>
<p>如果v10版本上述结果存在两种情况：</p>
<ul>
<li>如果time2定时器已经在执行队列中了，那么执行结果与上面结果相同。</li>
<li>如果time2定时器没有在执行对列中，执行结果为</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">timer2</span><br></pre></td></tr></table></figure>

<p>具体情况可以参考<code>poll</code>阶段的两种情况。</p>
<p>从下图可能更好理解：</p>
<p><img src="https://pic1.zhimg.com/v2-963090bd3b681de3313b4466b234f4f0_b.jpg" alt="img"></p>
<p><strong>setImmediate() 的setTimeout()的区别</strong></p>
<p><strong><code>setImmediate</code>和<code>setTimeout()</code>是相似的，但根据它们被调用的时间以不同的方式表现。</strong></p>
<ul>
<li><code>setImmediate()</code>设计用于在当前<code>poll</code>阶段完成后check阶段执行脚本 。</li>
<li><code>setTimeout()</code> 安排在经过最小（ms）后运行的脚本，在<code>timers</code>阶段执行。</li>
</ul>
<p><strong>举个例子</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>执行定时器的顺序将根据调用它们的上下文而有所不同。 如果从主模块中调用两者，那么时间将受到进程性能的限制。</strong></p>
<p><strong>其结果也不一致</strong></p>
<p><strong>如果在<code>I / O</code>周期内移动两个调用，则始终首先执行立即回调：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>其结果可以确定一定是<code>immediate =&gt; timeout</code>。<br>主要原因是在<code>I/O阶段</code>读取文件后，事件循环会先进入<code>poll</code>阶段，发现有<code>setImmediate</code>需要执行，会立即进入<code>check</code>阶段执行<code>setImmediate</code>的回调。<br>然后再进入<code>timers</code>阶段，执行<code>setTimeout</code>，打印<code>timeout</code>。</p>
<p><img src="https://pic4.zhimg.com/80/v2-a845e8e93fedead793b45e42c038e91f_720w.jpg" alt="img"></p>
<p><strong>Process.nextTick()</strong></p>
<p><strong><code>process.nextTick()</code>虽然它是异步API的一部分，但未在图中显示。这是因为<code>process.nextTick()</code>从技术上讲，它不是事件循环的一部分。</strong></p>
<ul>
<li><code>process.nextTick()</code>方法将 <code>callback</code> 添加到<code>next tick</code>队列。 一旦当前事件轮询队列的任务全部完成，在<code>next tick</code>队列中的所有<code>callbacks</code>会被依次调用。</li>
</ul>
<p><strong>换种理解方式：</strong></p>
<ul>
<li>当每个阶段完成后，如果存在 <code>nextTick</code> 队列，就会清空队列中的所有回调函数，并且优先于其他 <code>microtask</code> 执行。</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncApiCall</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>, bar); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在NodeV10中上述代码执行可能有两种答案，一种为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar <span class="number">1</span></span><br><span class="line">setTimeout</span><br><span class="line">setImmediate</span><br></pre></td></tr></table></figure>

<p>另一种为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar <span class="number">1</span></span><br><span class="line">setImmediate</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<p>无论哪种，始终都是先执行<code>process.nextTick(callback)</code>，打印<code>bar 1</code>。</p>
<p><strong>关于await问题参考了以下文章：</strong>.</p>
<p>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Fxianshenglu%2Fblog%2Fissues%2F60">promise, async, await, execution order</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fgithub.com%2Ftc39%2Fecma262%2Fpull%2F1250">Normative: Reduce the number of ticks in async/await</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fwww.zhihu.com%2Fquestion%2F268007969">async/await 在chrome 环境和 node 环境的 执行结果不一致，求解？</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fv8.js.cn%2Fblog%2Ffast-async%2F">更快的异步函数和 Promise</a>》</p>
<p><strong>其他内容参考了：</strong></p>
<p>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fsegmentfault.com%2Fa%2F1190000015559210">JS浏览器事件循环机制</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fsegmentfault.com%2Fa%2F1190000010622146">什么是浏览器的事件循环（Event Loop）？</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fsegmentfault.com%2Fa%2F1190000013861128">一篇文章教会你Event loop——浏览器和Node</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fcnodejs.org%2Ftopic%2F5a9108d78d6e16e56bb80882">不要混淆nodejs和浏览器中的event loop</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5c337ae06fb9a049bc4cd218">浏览器与Node的事件循环(Event Loop)有何区别?</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F">Tasks, microtasks, queues and schedules</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//juejin.im/book/5bdc715fe51d454e755f75ef/section/5be04a8e6fb9a04a072fd2cd%23heading-3">前端面试之道</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fwww.jianshu.com%2Fp%2F8e0ad01c41dc">Node.js介绍5-libuv的基本概念</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fnodejs.org%2Fen%2Fdocs%2Fguides%2Fevent-loop-timers-and-nexttick%2F">The Node.js Event Loop, Timers, and process.nextTick()</a>》<br>《<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%3A%2F%2Fnodejs.cn%2F">node官网</a>》</p>
<p><font color="red">注：</font>转载于：<a href="https://zhuanlan.zhihu.com/p/55511602" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/55511602</a></p>
<hr>
<h4 id="14-vue中对象数组去重"><a href="#14-vue中对象数组去重" class="headerlink" title="14. vue中对象数组去重"></a>14. <font color="#00AAF0">vue中对象数组去重</font></h4><p>其实很简单，一般的数组去重可以直接用 new Set() 方法即可，但是数组对象的话，比较复杂，不能直接用，我们可以采取间接的方法来去重</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unique(arr) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">arr</span>) =&gt;</span> !res.has(arr.id) &amp;&amp; res.set(arr.id, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面有一个示例，根据对象的id作为去重的依据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-button type=<span class="string">"primary"</span> size=<span class="string">"medium"</span> @click=<span class="string">"quChong()"</span>&gt;点击&lt;<span class="regexp">/el-button&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">quChong() &#123;</span><br><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'111'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">'111'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    name: <span class="string">'222'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">3</span>,</span><br><span class="line">    name: <span class="string">'333'</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'--------------------'</span>);</span><br><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">this</span>.unique(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line">&#125;,</span><br><span class="line">unique(arr) &#123;</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">arr</span>) =&gt;</span> !res.has(arr.id) &amp;&amp; res.set(arr.id, <span class="number">1</span>));</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p><img src="https://img2018.cnblogs.com/blog/1312098/201909/1312098-20190925165856499-111778537.png" alt="img"></p>
<hr>
<h4 id="15-回顾盒子模型之box-size属性"><a href="#15-回顾盒子模型之box-size属性" class="headerlink" title="15. 回顾盒子模型之box-size属性"></a>15. <font color="#00AAF0">回顾盒子模型之box-size属性</font></h4><p>先来看两张从网上找到的图：</p>
<p><img src="https://img-blog.csdn.net/20170312191531615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDMyNjM4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20170312191552052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDMyNjM4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>盒子模型是CSS中很重要的概念，它涉及到的无非就是内容(content)、填充(padding)、边框(border)、边界(margin)。但是从上两张图可以看出，盒子模型其实有两种类型：标准盒模型和IE盒模型。</p>
<p><strong>1) 标准盒模型</strong><br><code>box-sizing: content-box</code></p>
<blockquote>
<p>标准盒模型的width组成：content（不包含 padding 和 border）</p>
<p>for example：你给一个div的宽度设为200px，那这个div实际的宽度其实是200px再加上padding和border的值（和是大于等于200px的）。</p>
</blockquote>
<p><strong>2) IE盒模型</strong><br><code>box-sizing: border-box</code></p>
<blockquote>
<p>IE盒模型的width组成：content + 2 * padding + 2 * border</p>
<p>for example：你给一个div的宽度设为200px，那这个div内容的宽度其实只有200px减去 padding 和 border 的值。它实际宽度是小于或等于200px的。</p>
</blockquote>
<p><strong>对比总结</strong></p>
<blockquote>
<p>① box-sizing: content-box | border-box | inherit<br>② 他们的主要区别其实就是 width 包不包含 border 和 padding<br>③ box-sizing 默认值是 content-box，即默认是标准盒子模型</p>
</blockquote>
<hr>
<h4 id="16-Vue-set-和-this-set-区别"><a href="#16-Vue-set-和-this-set-区别" class="headerlink" title="16. Vue.set() 和 this.$set() 区别"></a>16. <font color="#00AAF0">Vue.set() 和 this.$set() 区别</font></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.set() 的源码：</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">set</span> &#125; from '../observer/index'</span><br><span class="line">...</span><br><span class="line">Vue.<span class="keyword">set</span> = <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">this.$<span class="keyword">set</span>()的源码：</span><br><span class="line">import &#123; <span class="keyword">set</span> &#125; from '../observer/index'</span><br><span class="line">Vue.prototype.$<span class="keyword">set</span> = <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line"> 总结：*都用的是<span class="keyword">set</span>方法 <span class="keyword">set</span>(target、key、val);，区别在于Vue.<span class="keyword">set</span>()是将<span class="keyword">set</span>函数绑定在Vue的构造函数上，this.$<span class="keyword">set</span>()是将<span class="keyword">set</span>函数挂载在Vue原型上。*</span><br></pre></td></tr></table></figure>

<p>源码分析:</p>
<blockquote>
<p> ① 如果当前环境不是生产环境并且   等于undefined或者null 或 target的数据类型是string、number、symbol、boolean中的一种，那么就抛出错误警告。<br> ② 如果key本来就是对象中的一个属性，并且key不是Object原型上的属性。说明这个key本来就在对象上面已经定义过了的，直接修改值就可以了，可以自动触发响应<br> target为数组  数组的长度设置为target.length和key中的最大值 防止越界<br> <code>defineReactive(ob.value, key, val)
 ob.dep.notify()
 return val</code><br> ③ defineReactive(ob.value, key, val) 的意思是给新加的属性添加依赖，以后再直接修改这个新的属性的时候就会触发页面渲染。</p>
<p> ob.dep.notify() 这句代码的意思是触发当前的依赖，所以页面就会进行重新渲染</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"about"</span>&gt;</span><br><span class="line">        &lt;div&gt;&#123;&#123;arr[<span class="number">0</span>]&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;&#123;obj.c&#125;&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"changeObj"</span>&gt;修改对象&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">        name: 'about',</span></span><br><span class="line"><span class="regexp">        data() &#123;</span></span><br><span class="line"><span class="regexp">            return &#123;</span></span><br><span class="line"><span class="regexp">                arr:[1],</span></span><br><span class="line"><span class="regexp">                obj: &#123;</span></span><br><span class="line"><span class="regexp">                    a: 1,</span></span><br><span class="line"><span class="regexp">                    b: 2</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;,</span></span><br><span class="line"><span class="regexp">        methods: &#123;</span></span><br><span class="line"><span class="regexp">            changeObj() &#123;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/ this.arr[0]=2;视图不更新</span></span><br><span class="line"><span class="regexp">                this.$set(this.arr, 0, 2);</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/ this.obj.c = 999;  视图不更新</span></span><br><span class="line"><span class="regexp">                this.$set(this.obj, 'c', 999);</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="17-JS对象转换为数组"><a href="#17-JS对象转换为数组" class="headerlink" title="17. JS对象转换为数组"></a>17. <font color="#00AAF0">JS对象转换为数组</font></h4><blockquote>
<p>① 通过<code>[].slice.call(对象)</code>语句；</p>
<p>② 使用<code>Array.from(对象)</code>语句，<code>Array.from()</code>方法可把可遍历的对象转换成数组（包括<code>Set</code>和<code>Map</code>数据结构）。</p>
</blockquote>
<h5 id="一、把类似数组的对象转换成数组"><a href="#一、把类似数组的对象转换成数组" class="headerlink" title="一、把类似数组的对象转换成数组"></a>一、把类似数组的对象转换成数组</h5><h6 id="1）什么是类似数组的对象（伪数组）"><a href="#1）什么是类似数组的对象（伪数组）" class="headerlink" title="1）什么是类似数组的对象（伪数组）"></a>1）什么是类似数组的对象（伪数组）</h6><p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>:<span class="string">"z"</span>,</span><br><span class="line">    <span class="string">'1'</span>:<span class="string">"y"</span>,</span><br><span class="line">    <span class="string">'2'</span>:<span class="string">"k"</span>,</span><br><span class="line">    length:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本质是有<code>length</code>属性，可以类似数组的获取元素的方式<code>arrayLike[0]</code>、<code>arrayLike[1]</code>去获取元素，也可以通过<code>arrayLike.length</code>获取伪数组的长度。</p>
<p>常见的伪数组有通过DOM操作获取的NodeList集合（document.querySelectorAll(‘p’)），以及函数形参arguments。</p>
<h6 id="2）转换方法"><a href="#2）转换方法" class="headerlink" title="2）转换方法"></a>2）转换方法</h6><p>方法一： 通过 <code>[].slice.call(arrayLike)</code></p>
<p>//获取当前dom的span组成的伪数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前dom的span组成的伪数组</span></span><br><span class="line"><span class="keyword">let</span> spanDomArr = <span class="built_in">document</span>.querySelectorAll(<span class="string">'span'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过数组的方法forEach遍历spanDomArr</span></span><br><span class="line"><span class="keyword">let</span> arr = [].slice.call(spanDomArr)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">//因为spanDomArr是伪数组，不支持数组的forEach，所以需要先转换成数组</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">span</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(span)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>方法二：通过 <code>Array.from(arrayLike)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前dom的span组成的伪数组</span></span><br><span class="line"><span class="keyword">let</span> spanDomArr = <span class="built_in">document</span>.querySelectorAll(<span class="string">'span'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//通过数组的方法forEach遍历spanDomArr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为spanDomArr是伪数组，不支持数组的forEach，所以需要先转换成数组</span></span><br><span class="line"><span class="built_in">Array</span>.from(spanDomArr).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">span</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(span)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="二、延伸-Array-from"><a href="#二、延伸-Array-from" class="headerlink" title="二、延伸 Array.from()"></a>二、延伸 <code>Array.from()</code></h5><h6 id="1）作用："><a href="#1）作用：" class="headerlink" title="1）作用："></a>1）作用：</h6><p>① 可以将类似数组的对象转换成数组；</p>
<p>② 可以把可遍历的对象转换成数组（包括ES6新增的数据结构Set和Map）；</p>
<h6 id="2）实际应用："><a href="#2）实际应用：" class="headerlink" title="2）实际应用："></a>2）实际应用：</h6><p>① 如果当前浏览器未部署此方法，可以使用<code>Array.prototype.slice</code>方法替代</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  方法名：objectToArray</span></span><br><span class="line"><span class="comment"> *  功能介绍：把类似数组的对象、可遍历的对象转换成数组</span></span><br><span class="line"><span class="comment"> *  参数：obj-需要转换的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> objectToArray = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.from ? <span class="built_in">Array</span>.from(obj) : [].slice.call(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>② 如果参数是数组，则会返回一个一模一样的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">"z"</span>,<span class="string">"y"</span>,<span class="string">"k"</span>])</span><br><span class="line"><span class="comment">//打印：["z","y","k"]</span></span><br></pre></td></tr></table></figure>



<p>③ 仅有<code>length</code>属性的对象，无法通过<code>array.from()</code>转换</p>
<p><img src="https://img.php.cn/upload/article/000/000/024/54dc6dafa374e20c48269ac07ce46ceb-0.png" alt="img"></p>
<p>④ <code>Array.from()</code>第二个参数：用来对每个元素进行处理，将处理后的值放入数组返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">"0"</span> : <span class="string">"z"</span>,</span><br><span class="line">    <span class="string">"1"</span> : <span class="string">"y"</span>,</span><br><span class="line">    <span class="string">"2"</span> : <span class="string">"k"</span>,</span><br><span class="line">    <span class="string">"length"</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike,x=&gt;x+<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span>=&gt;</span>x+<span class="string">'1'</span>)</span><br><span class="line"><span class="comment">//打印：["z1","y1","k1"]</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="18-数组遍历与箭头函数的注意点"><a href="#18-数组遍历与箭头函数的注意点" class="headerlink" title="18. 数组遍历与箭头函数的注意点"></a>18. <font color="#00AAF0">数组遍历与箭头函数的注意点</font></h4><ol>
<li>ES6之前的遍历方法都会跳过数组未赋值过的位置，也就是空位<code>undefined</code>，但是ES6新增的<code>for...of</code>方法就不会跳过</li>
<li>不能使用箭头函数来定义 watcher 函数 (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code> )。因为箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向组件实例， <code>this.updateAutocomplete</code> 将是 <code>undefined</code>。且data、vue生命周期也不行</li>
</ol>
<hr>
<h4 id="19-JS-号的行为"><a href="#19-JS-号的行为" class="headerlink" title="19. JS + 号的行为"></a>19. <font color="#00AAF0">JS <code>+</code> 号的行为</font></h4><blockquote>
<p>① 如果有一个操作数是字符串，那么把另一个操作数转成字符串执行连接</p>
<p>② 如果有一个操作数是对象，那么调用对象的<code>valueOf</code>方法转成原始值，如果没有该方法或调用后仍是非原始值，则调用<code>toString</code>方法</p>
<p>③ 其他情况下，两个操作数都会被转成数字执行加法操作</p>
<p><font color="red">注：</font> 数组和对象调用<code>toString</code>方法转成字符串的结果不一样，数组会把每个元素都转成</p>
<p><font color="red"><strong>一个</strong></font>字符串（包括“，”逗号），而对象则变为<code>&#39;[object Object]&#39;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">num1</span>: <span class="number">1</span>, <span class="attr">num2</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.toSting()) <span class="comment">// '1,2,3'</span></span><br><span class="line"><span class="built_in">console</span>.log(a.toSting().length) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(b.toSting()) <span class="comment">// '[object Object]'</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>eg：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="literal">NaN</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"1"</span> + <span class="number">3</span>) <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="literal">null</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + &#123;&#125;) <span class="comment">// 1[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + []) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log([] + &#123;&#125;) <span class="comment">// [object Object]</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="20-JS-更改对象中的属性名"><a href="#20-JS-更改对象中的属性名" class="headerlink" title="20. JS 更改对象中的属性名"></a>20. <font color="#00AAF0">JS 更改对象中的属性名</font></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj).replace(<span class="regexp">/name/g</span>,<span class="string">"label"</span>))</span><br><span class="line"><span class="comment">// 1. obj 是需要更改属性的对象</span></span><br><span class="line"><span class="comment">// 2. replace(/name/g,"label"),将对象里所有属性为name的都修改成label</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="21-CSS省略号相关设置（限制n行）"><a href="#21-CSS省略号相关设置（限制n行）" class="headerlink" title="21. CSS省略号相关设置（限制n行）"></a>21. <font color="#00AAF0">CSS省略号相关设置（限制n行）</font></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>; <span class="comment">/*设置方向*/</span></span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 4; <span class="comment">/*设置超过为省略号的行数*/</span></span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="22-怎么检查JavaScript对象上是否存在一个属性？"><a href="#22-怎么检查JavaScript对象上是否存在一个属性？" class="headerlink" title="22. 怎么检查JavaScript对象上是否存在一个属性？"></a>22. <font color="#00AAF0">怎么检查JavaScript对象上是否存在一个属性？</font></h4><p>在JavaScript中，有几种方法可以检查对象上是否存在一个属性。选择哪种方法在很大程度上取决于实际需求，所以需要我们了解每种方法的工作原理。</p>
<h5 id="1-真值检查"><a href="#1-真值检查" class="headerlink" title="(1) 真值检查"></a>(1) <strong>真值检查</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="string">'some string'</span>,</span><br><span class="line">  c: [<span class="number">0</span>],</span><br><span class="line">  d: &#123;<span class="attr">a</span>: <span class="number">0</span>&#125;,</span><br><span class="line">  e: <span class="literal">undefined</span>,</span><br><span class="line">  f: <span class="literal">null</span>,</span><br><span class="line">  g: <span class="string">''</span>,</span><br><span class="line">  h: <span class="literal">NaN</span>,</span><br><span class="line">  i: &#123;&#125;,</span><br><span class="line">  j: [],</span><br><span class="line">  deleted: <span class="string">'value'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> myObj.deleted</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(!!myObj[<span class="string">'a'</span>]) <span class="comment">// 1, true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!myObj[<span class="string">'b'</span>]) <span class="comment">// 'some string', true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!myObj[<span class="string">'c'</span>]) <span class="comment">// [0], true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!myObj[<span class="string">'d'</span>]) <span class="comment">// &#123;a: 0&#125;, true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!myObj[<span class="string">'e'</span>]) <span class="comment">// undefined, false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!myObj[<span class="string">'f'</span>]) <span class="comment">// null, false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!myObj[<span class="string">'g'</span>]) <span class="comment">// '', false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!myObj[<span class="string">'h'</span>]) <span class="comment">// NaN, false</span></span><br><span class="line"><span class="built_in">console</span>.log(!!myObj[<span class="string">'i'</span>]) <span class="comment">// &#123;&#125;, true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!myObj[<span class="string">'j'</span>]) <span class="comment">// [], true</span></span><br><span class="line"><span class="built_in">console</span>.log(!!myObj[<span class="string">'deleted'</span>]) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>正如你所看到的，这导致了几个假值的问题，所以使用这种方法时要非常小心。</p>
<h5 id="2-in-操作符"><a href="#2-in-操作符" class="headerlink" title="(2) in 操作符"></a>(2) <strong><code>in</code> 操作符</strong></h5><p>如果一个属性存在于一个对象或其原型链上，in操作符返回true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">  someProperty: <span class="string">'someValue'</span>,</span><br><span class="line">  someUndefinedProp: <span class="literal">undefined</span>,</span><br><span class="line">  deleted: <span class="string">'value'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> myObj.deleted</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'someProperty'</span> <span class="keyword">in</span> myObj) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'someUndefinedProp'</span> <span class="keyword">in</span> myObj) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'toString'</span> <span class="keyword">in</span> myObj) <span class="comment">// true (inherited 继承)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'deleted'</span> <span class="keyword">in</span> myObj) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>in操作符不会受到假值问题的影响。然而，它也会对原型链上的属性返回true。这可能正是我们想要的，如果我们不需要对原型链上对属性进行判断，可以使用下面这种方法。</p>
<h5 id="3-hasOwnProperty"><a href="#3-hasOwnProperty" class="headerlink" title="(3) hasOwnProperty()"></a>(3) <strong><code>hasOwnProperty()</code></strong></h5><p><code>hasOwnProperty()</code>继承自<code>Object.HasOwnProperty()</code>。和in操作符一样，它检查对象上是否存在一个属性，但不考虑原型链。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">  someProperty: <span class="string">'someValue'</span>,</span><br><span class="line">  someUndefinedProp: <span class="literal">undefined</span>,</span><br><span class="line">  deleted: <span class="string">'value'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> myObj.deleted</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObj.hasOwnProperty(<span class="string">'someProperty'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.hasOwnProperty(<span class="string">'someUndefinedProp'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.hasOwnProperty(<span class="string">'toString'</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(myObj.hasOwnProperty(<span class="string">'deleted'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>不过要注意的一点是，并不是每个对象都继承自<code>Object</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cleanObj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">cleanObj.someProp = <span class="string">'someValue'</span></span><br><span class="line"><span class="comment">// TypeError: cleanObj.hasOwnProperty is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(cleanObj.hasOwnProperty(<span class="string">'someProp'</span>))</span><br></pre></td></tr></table></figure>

<p>如果遇到这种罕见的情况，还可以按以下方式使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cleanObj = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">cleanObj.someProp = <span class="string">'someValue'</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).hasOwnProperty.call(cleanObj,<span class="string">'someProp'</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="23-JS-Symbol-类型"><a href="#23-JS-Symbol-类型" class="headerlink" title="23 JS  Symbol 类型 "></a>23 <font color="#00AAF0">JS  <code>Symbol</code> 类型 </font></h4><h5 id="1-Symbol-类型"><a href="#1-Symbol-类型" class="headerlink" title="(1) Symbol 类型"></a>(1) <strong><code>Symbol</code> 类型</strong></h5><p>symbol的实例是唯一的不可变的, 用于确保对象的属性不重复</p>
<p>使用方式 : 调用 Symbol( 标识 ) 函数 返回一个符号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [a]: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)  <span class="comment">// &#123;Symbol(a): 1&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-Symbol-函数不可以-new"><a href="#2-Symbol-函数不可以-new" class="headerlink" title="(2) Symbol() 函数不可以 new"></a>(2) <strong><code>Symbol()</code> 函数不可以 <code>new</code></strong></h5><p>符号代表唯一的值, 但是我就想用一个符号呢 ?</p>
<p>通过 <code>Symbol.for()</code> 创建一个全局符号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Symbol</span>.for(<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">const</span> b2 = <span class="built_in">Symbol</span>.for(<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [a]: <span class="number">1</span>,</span><br><span class="line">  [b]: <span class="number">2</span>,</span><br><span class="line">  [b2]: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b === b2) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;Symbol(a): 1, Symbol(b): 3&#125;</span></span><br><span class="line"><span class="comment">// key通过覆盖替换 不必疑惑</span></span><br><span class="line"><span class="comment">// b 和 b2 指向同一个符号</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>Symbol.keyFor()</code> 查看全局符号 参数是全局符号 返回符号的描述</p>
<p>如果传的不是全局符号 返回<code>undefined</code></p>
<p>如果传的不是符号 报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="built_in">Symbol</span>.for(<span class="string">'b123'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(b)) <span class="comment">// b123</span></span><br></pre></td></tr></table></figure>

<h5 id="3-常用的内置符号-Symbol的工厂函数"><a href="#3-常用的内置符号-Symbol的工厂函数" class="headerlink" title="(3) 常用的内置符号 Symbol的工厂函数"></a>(3) 常用的内置符号 <code>Symbol</code>的工厂函数</h5><h6 id="①-Symbol-asyncIterator"><a href="#①-Symbol-asyncIterator" class="headerlink" title="① Symbol.asyncIterator"></a>① <code>Symbol.asyncIterator</code></h6><p>此方法返回对象的默认的异步迭代器, 可由 <code>for - await - of</code> 使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for await of 会调用对象以[Symbol.asyncIterator]为键的函数 该函数返回异步的generator   </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>(n) &#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n</span><br><span class="line">        <span class="keyword">this</span>.i = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">async</span> *[<span class="built_in">Symbol</span>.asyncIterator]() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">this</span>.i &lt; <span class="keyword">this</span>.n) &#123;</span><br><span class="line">          <span class="keyword">yield</span> <span class="built_in">Promise</span>.resolve(<span class="keyword">this</span>.i++)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> Foo(<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> x <span class="keyword">of</span> p) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()  <span class="comment">// 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>


<h6 id="②-Symbol-hasInstance"><a href="#②-Symbol-hasInstance" class="headerlink" title="② Symbol.hasInstance"></a>② <code>Symbol.hasInstance</code></h6><p>该方法判断一个对象是不是构造函数的实例 , 由 instanceof 使用 , 也就是说 instanceof 检测数据类型时的原理就是调用了 <code>Symbol.hasInstance</code></p>
<p>这个属性被定义在 Function 上 所以函数和类都有 <code>Symbol.hasInstance</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="built_in">Symbol</span>.hasInstance]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> demo = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(Foo[<span class="built_in">Symbol</span>.hasInstance](demo)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(demo <span class="keyword">instanceof</span> Foo) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 之所以会使false 是因为我重新定义了  [Symbol.hasInstance]() 函数   默认情况下是true</span></span><br></pre></td></tr></table></figure>


<h6 id="③-Symbol-isConcatSpreadable"><a href="#③-Symbol-isConcatSpreadable" class="headerlink" title="③ Symbol.isConcatSpreadable"></a>③ <code>Symbol.isConcatSpreadable</code></h6><p>这个符号作为属性返回一个布尔值 , 决定拼接数组时是否展开 , 默认为 true</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>]</span><br><span class="line">arr1[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">2</span>]</span><br><span class="line">arr2[<span class="built_in">Symbol</span>.isConcatSpreadable] = <span class="literal">false</span></span><br><span class="line">arr = arr.concat(arr1, arr2)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">//  [0, 1, Array(1)]</span></span><br></pre></td></tr></table></figure>


<h6 id="④-Symbol-iterator"><a href="#④-Symbol-iterator" class="headerlink" title="④ Symbol.iterator"></a>④ <code>Symbol.iterator</code></h6><p>此方法返回对象默认的迭代器 <code>for...of</code> 循环时就会调用对象的 <code>Symbol.iterator</code> 函数(返回一个迭代器对象)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(n) &#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.i = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.i &lt; <span class="keyword">this</span>.n) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">this</span>.i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> Foo(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> p) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>



<h6 id="⑤-Symbol-match-replace-search-species-split"><a href="#⑤-Symbol-match-replace-search-species-split" class="headerlink" title="⑤ Symbol.match/replace/search/species/split"></a>⑤ <code>Symbol.match/replace/search/species/split</code></h6><p>Symbol允许我们自定义某些函数, 以改变函数原本的行为</p>
<p>接下来简单说明一下</p>
<p><strong><code>match</code></strong></p>
<p><code>match</code> 方法返回字符串匹配正则表达式的结果<br>即使参数传入的不是正则表达式 也会调用 <code>new RegExp(&#39;xxx&#39;)</code> 转为正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的match</span></span><br><span class="line">    <span class="keyword">const</span> str = <span class="string">'abcdefg'</span></span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/b/</span></span><br><span class="line">    <span class="keyword">const</span> res = str.match(reg)</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// ['b', index: 1, input: 'abcdefg', groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的match</span></span><br><span class="line">    <span class="keyword">const</span> str = <span class="string">'abcdefg'</span></span><br><span class="line">    <span class="keyword">const</span> a = &#123;</span><br><span class="line">      [<span class="built_in">Symbol</span>.match](target) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = str.match(a)</span><br><span class="line">    <span class="built_in">console</span>.log(res)  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong><code>replace</code></strong></p>
<p><code>replace</code> 方法传入的参数替换字符串匹配正则表达式的结果返回新的字符串<br>即使参数传入的不是正则表达式 也会调用 <code>new RegExp(&#39;xxx&#39;)</code> 转为正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的replace</span></span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">'abcdefg'</span></span><br><span class="line">    str = str.replace(<span class="string">'abc'</span>, <span class="string">'111'</span>) <span class="comment">// 等价于 str = str.replace(/abc/, '111')</span></span><br><span class="line">    <span class="built_in">console</span>.log(str); <span class="comment">// '111defg'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义的replace</span></span><br><span class="line">    <span class="keyword">let</span> str1 = <span class="string">'123'</span></span><br><span class="line">    <span class="keyword">const</span> target = []</span><br><span class="line">    target[<span class="built_in">Symbol</span>.replace] = <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;rest[<span class="number">1</span>]&#125;</span><span class="subst">$&#123;rest[<span class="number">0</span>]&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.dir(target)</span><br><span class="line">    str1 = str1.replace(target, <span class="string">'333'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(str1) <span class="comment">// 333123</span></span><br></pre></td></tr></table></figure>



<p><strong><code>search</code></strong></p>
<p><code>search</code> 方法传入的参数为目标字符中出现的位置  会调用参数的 <code>Symbol.search</code> 进行求值<br>即使参数传入的不是正则表达式 也会调用 <code>new RegExp(&#39;xxx&#39;)</code> 转为正则表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'abcdefg'</span></span><br><span class="line"><span class="keyword">const</span> res = str.search(<span class="string">'d'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 自定义 search 方法</span></span><br><span class="line"><span class="keyword">const</span> demo = &#123;&#125;</span><br><span class="line">demo[<span class="built_in">Symbol</span>.search] = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(demo)) <span class="number">5</span></span><br><span class="line"><span class="comment">// 执行原理  </span></span><br><span class="line"><span class="comment">// 调用String.proptype.search() </span></span><br><span class="line"><span class="comment">// 该方法调用正则表达式的[Symbol.search]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.prototype.search)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.prototype[<span class="built_in">Symbol</span>.search])</span><br></pre></td></tr></table></figure>



<p><strong><code>species</code></strong></p>
<p>如果你定义一个扩展数组类 那么这个类的实例对象默认是同时指向父类和Array这个构造函数<br>如果你想只返回Array替换掉他的父类  那么可以使用静态方法 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static get [Symbol.species]() &#123;</span></span><br><span class="line"><span class="comment">//   return Array</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arr</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arr1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d1 = <span class="keyword">new</span> Arr()</span><br><span class="line"><span class="built_in">console</span>.log(d1.concat([]) <span class="keyword">instanceof</span> Arr) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(d1 <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d2 = <span class="keyword">new</span> Arr1()</span><br><span class="line"><span class="built_in">console</span>.log(d2.concat([]) <span class="keyword">instanceof</span> Arr1) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(d2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<p><strong><code>split</code></strong></p>
<p><code>split()</code> 方法以指定字符串分割调用对象, 在此方法调用时会使用以 <code>Symbol.split</code> 为键的函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'abcd'</span></span><br><span class="line"><span class="keyword">const</span> res = str.split(<span class="string">''</span>) <span class="comment">// 等价于 str.split(new RegExp(''))</span></span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br><span class="line"><span class="comment">// 自定义 split</span></span><br><span class="line"><span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">''</span>)</span><br><span class="line">reg[<span class="built_in">Symbol</span>.split] = <span class="function">(<span class="params">target</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> res1 = str.split(reg)</span><br><span class="line"><span class="built_in">console</span>.log(res1); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>


<h6 id="⑥-Symbol-toPrimitive"><a href="#⑥-Symbol-toPrimitive" class="headerlink" title="⑥ Symbol.toPrimitive"></a>⑥ <code>Symbol.toPrimitive</code></h6><p>对象转成字符串会被 <code>String</code> 函数转化成 <code>&#39;[object Object]&#39;</code><br>如果想对对象进行加减运算 , 你可以通过定义 <code>Symbol.toPrimitive</code> 来实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + obj);      <span class="comment">// 1[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> - obj);      <span class="comment">//  NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(obj));  <span class="comment">//  [object Object]</span></span><br><span class="line">obj[<span class="built_in">Symbol</span>.toPrimitive] = <span class="function">(<span class="params">hint</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'none'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + obj);     <span class="comment">// 1none</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> - obj);     <span class="comment">//  1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(obj)); <span class="comment">//  1</span></span><br></pre></td></tr></table></figure>



<h6 id="⑦-Symbol-toStringTag"><a href="#⑦-Symbol-toStringTag" class="headerlink" title="⑦ Symbol.toStringTag"></a>⑦ <code>Symbol.toStringTag</code></h6><p>对象使用 <code>toString</code> 方法时 会使用 <code>Symbol.toStringTag</code> 的返回值作为数组中的第二项<br>我的理解就是 <code>Symbol.toStringTag</code> 方法可以改变(实例对象)的 <code>toString</code> 输出指定的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.toString()) <span class="comment">// [object Object]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> P()</span><br><span class="line"><span class="built_in">console</span>.log(obj2.toString()) <span class="comment">// [object Object]</span></span><br><span class="line">obj2[<span class="built_in">Symbol</span>.toStringTag] = <span class="string">'P'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.toString()) <span class="comment">// [object P]</span></span><br></pre></td></tr></table></figure>


<h6 id="⑧-Symbol-unscopables"><a href="#⑧-Symbol-unscopables" class="headerlink" title="⑧ Symbol.unscopables"></a>⑧ <code>Symbol.unscopables</code></h6><p> 在 <code>with</code> 语句中 访问的变量默认都会访问器参数对象的属性<br> 使用 <code>Symbol.unscopables</code> 可以指定对象哪些属性不在<code>with</code>环境下生效</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'a'</span>,</span><br><span class="line">  b: <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.unscopables] = &#123;</span><br><span class="line">  b: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 报错 b is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="24-JS实现将文本或JSON内容下载到文件中"><a href="#24-JS实现将文本或JSON内容下载到文件中" class="headerlink" title="24. JS实现将文本或JSON内容下载到文件中"></a>24. <font color="#00AAF0">JS实现将文本或JSON内容下载到文件中</font></h4><p>前端开发可能遇到这样的需求场景：<strong>需要将页面上的文本内容下载到文件中，内容可能是某个大的文本字段，比如博客文章，也可能是后端接口返回的 JSON 数据。</strong></p>
<h5 id="1-下载文本"><a href="#1-下载文本" class="headerlink" title="1) 下载文本"></a>1) 下载文本</h5><p>那么需要如何实现 JS 下载文本内容呢？可以借助于 <strong>Blob 对象和 a 标签的 download属性</strong> 来实现，具体代码如下：</p>
<blockquote>
<p><code>Blob</code> 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 <code>ReadableStream</code> 来用于数据操作；</p>
<p><code>a</code> 标签的 download 属性是 HTML5 中新增的，用来直接进行文件下载；</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadText</span>(<span class="params">fileName, text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL || <span class="built_in">window</span></span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([text])</span><br><span class="line">    <span class="keyword">const</span> saveLink = <span class="built_in">document</span>.createElementNS(<span class="string">'http://www.w3.org/1999/xhtml'</span>, <span class="string">'a'</span>)</span><br><span class="line">    saveLink.href = url.createObjectURL(blob)</span><br><span class="line">    <span class="comment">// 设置 download 属性</span></span><br><span class="line">    saveLink.download = fileName</span><br><span class="line">    saveLink.click()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来测试一下，可以直接在 Chrome 的 console 中进行测试：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloadText(<span class="string">'test.txt'</span>, <span class="string">'测试'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://segmentfault.com/img/bVc0fdp" alt="img"></p>
<p>运行后，可以看到浏览器会下载一个名为 test.txt 的文件。</p>
<h5 id="2-下载JSON"><a href="#2-下载JSON" class="headerlink" title="2) 下载JSON"></a>2) 下载JSON</h5><p>有时候后端接口返回了一个JSON对象，为了方便查看和核对数据，可能想将其下载到文件中，那么只需要将下载文本的方法稍微改造一下即可，具体代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadJson</span>(<span class="params">fileName, json</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> jsonStr = (json <span class="keyword">instanceof</span> <span class="built_in">Object</span>) ? <span class="built_in">JSON</span>.stringify(json) : json</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> url = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL || <span class="built_in">window</span></span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([jsonStr])</span><br><span class="line">    <span class="keyword">const</span> saveLink = <span class="built_in">document</span>.createElementNS(<span class="string">'http://www.w3.org/1999/xhtml'</span>, <span class="string">'a'</span>)</span><br><span class="line">    saveLink.href = url.createObjectURL(blob)</span><br><span class="line">    saveLink.download = fileName</span><br><span class="line">    saveLink.click()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloadJson(<span class="string">'test.json'</span>, &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'js'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>运行后，浏览器会自动下载一个名为 test.json 的文件，其内容如下：</p>
<h5 id="3-下载JSON并格式化"><a href="#3-下载JSON并格式化" class="headerlink" title="3) 下载JSON并格式化"></a>3) 下载JSON并格式化</h5><p>有的时候可能希望保存到文件中的 json 数据是格式化的，这样方便查看，那么只需要稍微调整一下 <code>JSON.stringify()</code> 方法即可，先来看看 <code>JSON.stringify()</code> 方法的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(value[, replacer [, space]])</span><br><span class="line">value</span><br></pre></td></tr></table></figure>

<ul>
<li>将要序列化成 一个 JSON 字符串的值。</li>
</ul>
<p><code>replacer</code> 可选</p>
<ul>
<li>如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。</li>
</ul>
<p><code>space</code> 可选</p>
<ul>
<li>指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为 10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过 10 个字母，取其前 10 个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。</li>
</ul>
<p>如果想要格式化 JSON，那么可以传入一个 space 参数，具体如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(json, <span class="literal">null</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>除了使用4个空格外，还可以制表符（\t）来缩进，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(json, <span class="literal">null</span>, <span class="string">'\t'</span>)</span><br></pre></td></tr></table></figure>

<p>下载格式化JSON方法修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">downloadJson</span>(<span class="params">fileName, json</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> jsonStr = (json <span class="keyword">instanceof</span> <span class="built_in">Object</span>) ? <span class="built_in">JSON</span>.stringify(json, <span class="literal">null</span>, <span class="number">4</span>) : json</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> url = <span class="built_in">window</span>.URL || <span class="built_in">window</span>.webkitURL || <span class="built_in">window</span></span><br><span class="line">    <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([jsonStr])</span><br><span class="line">    <span class="keyword">const</span> saveLink = <span class="built_in">document</span>.createElementNS(<span class="string">'http://www.w3.org/1999/xhtml'</span>, <span class="string">'a'</span>)</span><br><span class="line">    saveLink.href = url.createObjectURL(blob)</span><br><span class="line">    saveLink.download = fileName</span><br><span class="line">    saveLink.click()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来测试一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">downloadJson(<span class="string">'test.json'</span>, &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'js'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>运行后，浏览器会自动下载一个名为 test.json 的文件，其内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="25-JavaScript-继承"><a href="#25-JavaScript-继承" class="headerlink" title="25. JavaScript 继承"></a>25. <font color="#00AAF0">JavaScript 继承</font></h4><blockquote>
<p>（1）原型链继承</p>
<p>（2）借助构造函数继承（经典继承）</p>
<p>（3）组合继承：原型链 + 借用构造函数（最常用）</p>
<p>（4）原型式继承 （Object.create）</p>
<p>（5）寄生式继承</p>
<p>（6）寄生组合式继承（最理想）</p>
<p>（7）ES6中的继承</p>
</blockquote>
<h5 id="（1）-原型链继承"><a href="#（1）-原型链继承" class="headerlink" title="（1） 原型链继承"></a>（1） 原型链继承</h5><p>子类型的原型为父类型的一个实例对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'bigStar'</span></span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subName = <span class="string">'litterStar'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心代码: 子类型的原型为父类型的一个实例对象</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line">child1.getName() <span class="comment">// bigStar</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">'pink'</span>)</span><br><span class="line"><span class="comment">// 修改 child1.colors 会影响 child2.colors</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors) <span class="comment">// [ 'red', 'blue', 'yellow', 'pink' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors) <span class="comment">// [ 'red', 'blue', 'yellow', 'pink' ]</span></span><br></pre></td></tr></table></figure>

<p>注意核心代码： <code>Child.prototype = new Parent()</code></p>
<p><strong>特点：</strong></p>
<ul>
<li>父类新增在构造函数上面的方法，子类都能访问到</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>来自原型对象的所有属性被所有实例共享，child1修改 colors 会影响child2的 colors</p>
</li>
<li><p>创建子类实例时，无法向父类的构造函数传参</p>
</li>
</ul>
<h5 id="（2）借助构造函数继承（经典继承）"><a href="#（2）借助构造函数继承（经典继承）" class="headerlink" title="（2）借助构造函数继承（经典继承）"></a>（2）借助构造函数继承（经典继承）</h5><p>在子类的构造函数中使用 <code>call()</code> 或者 <code>apply()</code> 调用父类型构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 核心代码：“借调”父类型的构造函数</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="string">'litterStar'</span>)</span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> Child(<span class="string">'luckyStar'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1.name); <span class="comment">// litterStar</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.name); <span class="comment">// luckyStar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种方式只是实现部分的继承，如果父类的原型还有方法和属性，子类是拿不到这些方法和属性的。</span></span><br><span class="line">child1.getName() <span class="comment">// TypeError: child1.getName is not a function</span></span><br></pre></td></tr></table></figure>

<p>注意核心代码： <code>Parent.call(this, name);</code></p>
<p><strong>特点：</strong></p>
<ul>
<li>避免引用类型的属性被所有实例共享</li>
<li>创建子类实例时，可以向父类传递参数</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>实例并不是父类的实例，只是子类的实例</li>
<li>只能继承父类的实例属性和方法，不能继承原型属性和方法</li>
<li>无法实现函数复用，每次创建实例都会创建一遍方法，影响性能</li>
</ul>
<h5 id="（3）组合继承：原型链-借用构造函数（最常用）"><a href="#（3）组合继承：原型链-借用构造函数（最常用）" class="headerlink" title="（3）组合继承：原型链 + 借用构造函数（最常用）"></a>（3）组合继承：原型链 + 借用构造函数（最常用）</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 核心代码①</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心代码②: 子类型的原型为父类型的一个实例对象</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过子类给父类的构造函数传参</span></span><br><span class="line"><span class="keyword">let</span> child1 = <span class="keyword">new</span> Child(<span class="string">'litterStar'</span>)</span><br><span class="line"><span class="keyword">let</span> child2 = <span class="keyword">new</span> Child(<span class="string">'luckyStar'</span>)</span><br><span class="line">child1.getName() <span class="comment">// litterStar</span></span><br><span class="line">child2.getName() <span class="comment">// luckyStar</span></span><br><span class="line"></span><br><span class="line">child1.colors.push(<span class="string">'pink'</span>)</span><br><span class="line"><span class="comment">// 修改 child1.colors 不会影响 child2.colors</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors) <span class="comment">// [ 'red', 'blue', 'yellow', 'pink' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors) <span class="comment">// [ 'red', 'blue', 'yellow' ]</span></span><br></pre></td></tr></table></figure>

<p>注意核心代码： <code>Parent.call(this, name)</code>和 <code>Child.prototype = new Parent()</code></p>
<p><strong>特点：</strong></p>
<ul>
<li>融合了原型链继承和借用构造函数的优点，称为JavaScript中最常用的继承模式。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>调用了两次父类构造函数，生成了两份实例<ul>
<li>一次是设置子类型实例的原型的时候 <code>Child.prototype = new Parent()</code></li>
<li>一次是创建子类型实例的时候 <code>let child1 = new Child(&#39;litterStar&#39;)</code>, 调用 new 会执行 <code>Parent.call(this, name)</code>,此时会再次调用一次 <code>Parent</code>构造函数</li>
</ul>
</li>
</ul>
<h5 id="（4）原型式继承-（Object-create）"><a href="#（4）原型式继承-（Object-create）" class="headerlink" title="（4）原型式继承 （Object.create）"></a>（4）原型式继承 （Object.create）</h5><p>借助原型可以基于现有方法来创建对象，var B = Object.create(A) 以A对象为原型，生成A对象，B继承了A的所有属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'star'</span>,</span><br><span class="line">    colors: [<span class="string">'red'</span>, <span class="string">'blue'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心代码：Object.create</span></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="built_in">Object</span>.create(person)</span><br><span class="line"><span class="keyword">const</span> person2= <span class="built_in">Object</span>.create(person)</span><br><span class="line"></span><br><span class="line">person1.name = <span class="string">'litterstar'</span></span><br><span class="line">person2.name = <span class="string">'luckystar'</span></span><br><span class="line"></span><br><span class="line">person1.colors.push(<span class="string">'yellow'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.colors); <span class="comment">// [ 'red', 'blue', 'yellow' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.colors); <span class="comment">// [ 'red', 'blue', 'yellow' ]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意核心代码： <code>const person1 = Object.create(person)</code></p>
</blockquote>
<p><strong>特点</strong></p>
<ul>
<li>没有严格意义上的构造函数，借助原型可以基于已有对象创建新对象</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>来自原型对象的所有属性被所有实例共享，person1修改 colors 会影响person2的 colors，这点跟原型链继承一样。</li>
</ul>
<h5 id="（5）寄生式继承"><a href="#（5）寄生式继承" class="headerlink" title="（5）寄生式继承"></a>（5）寄生式继承</h5><p>创建一个用于封装继承过程的函数，该函数在内部以某种方式来增强对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">original</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过调用函数创新一个新对象</span></span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(original)</span><br><span class="line">    <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">    clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>缺点：</strong></p>
<ul>
<li>每次创建对象都会创建一遍方法，跟借助构造函数模式一样</li>
</ul>
<h5 id="（6）寄生组合式继承（最理想的）"><a href="#（6）寄生组合式继承（最理想的）" class="headerlink" title="（6）寄生组合式继承（最理想的）"></a>（6）寄生组合式继承（最理想的）</h5><p>我们可以先回忆一下JavaScript最常用的继承模式： 组合继承（原型链 + 借用构造函数），它的最大缺点是会调用两次父构造函数（<code>Child.prototype = new Parent()</code>和 <code>let child1 = new Child(&#39;litterStar&#39;)</code>）。</p>
<p>我们是否可以想办法是调用一次？可以让 <code>Child.prototype</code> 访问到 <code>Parent.prototype</code>。</p>
<p>我们不能直接使用 <code>Child.prototype = Parent.prototype</code>来实现，因为会出现一些副作用，你可能在修改 <code>Child.prototype</code> 的时候会修改<code>Parent.prototype</code>。</p>
<p>可以使用 <code>Object.create(...)</code>来实现</p>
<blockquote>
<p><code>Object.create</code> MDN上的解释：它会创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 核心代码①</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心代码②</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line">Child.prototype.constructor = Child</span><br></pre></td></tr></table></figure>

<p>注意核心代码： <code>Parent.call(this, name);</code>和 <code>Child.prototype = Object.create(Parent.prototype);</code></p>
<p>寄生组合式继承，集寄生式继承和组合式继承的优点，是引用类型最理想的继承范式。</p>
<h5 id="（7）-ES6-中class的继承"><a href="#（7）-ES6-中class的继承" class="headerlink" title="（7） ES6 中class的继承"></a>（7） ES6 中class的继承</h5><p>ES6中引入了<code>class</code>关键字，可以通过<code>extends</code>关键字实现继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age, color) &#123;</span><br><span class="line">        <span class="comment">// 调用父类的constructor(name, age)</span></span><br><span class="line">        <span class="keyword">super</span>(name, age)</span><br><span class="line">        <span class="keyword">this</span>.color = color</span><br><span class="line">    &#125;</span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString() <span class="comment">// 调用父类的toString()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>class</code>关键字只是原型的语法糖，JavaScript继承仍然是基于原型实现的。</p>
<hr>
<h4 id="26-JS-中-this-的理解"><a href="#26-JS-中-this-的理解" class="headerlink" title="26. JS 中 this 的理解"></a>26. <font color="#00AAF0">JS 中 <code>this</code> 的理解</font></h4><p>其实JS中的<code>this</code>是一个非常简单的东西，只需要理解它的执行规则就OK。</p>
<p>在这里不想像其他博客一样展示太多的代码例子弄得天花乱坠， 反而不易理解。</p>
<p><code>call/apply/bind</code>可以显式绑定, 这里就不说了。</p>
<p>主要这些场隐式绑定的场景讨论：</p>
<blockquote>
<p>（1）全局上下文</p>
<p>（2）直接调用函数</p>
<p>（3）对象.方法的形式调用</p>
<p>（4）DOM事件绑定(特殊)</p>
<p>（5）new构造函数绑定</p>
<p>（6）箭头函数</p>
</blockquote>
<h5 id="（1）-全局上下文"><a href="#（1）-全局上下文" class="headerlink" title="（1） 全局上下文"></a>（1） 全局上下文</h5><p>全局上下文<strong>默认</strong><code>this</code>指向<code>window</code>，<strong>严格模式</strong>下指向<code>undefined</code>。</p>
<h5 id="（2）-直接调用函数"><a href="#（2）-直接调用函数" class="headerlink" title="（2） 直接调用函数"></a>（2） 直接调用函数</h5><p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func = obj.a</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>这种情况是直接调用。this相当于全局上下文的情况。</p>
<h5 id="（3）-对象-方法的形式调用"><a href="#（3）-对象-方法的形式调用" class="headerlink" title="（3） 对象.方法的形式调用"></a>（3） 对象.方法的形式调用</h5><p>还是刚刚的例子，我如果这样写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.a()</span><br></pre></td></tr></table></figure>

<p>这就是 <code>对象.方法</code> 的情况，this指向这个对象</p>
<h5 id="（4）-DOM事件绑定"><a href="#（4）-DOM事件绑定" class="headerlink" title="（4） DOM事件绑定"></a>（4） DOM事件绑定</h5><p><code>onclick</code>和<code>addEventerListener</code>中<code>this</code>默认指向绑定事件的元素。</p>
<p>IE比较奇异，使用<code>attachEvent</code>，里面的<code>this</code>默认指向<code>window</code>。</p>
<h5 id="（5）-new-构造函数"><a href="#（5）-new-构造函数" class="headerlink" title="（5） new+构造函数"></a>（5） new+构造函数</h5><p>此时构造函数中的this指向实例对象。</p>
<h5 id="（6）-箭头函数？"><a href="#（6）-箭头函数？" class="headerlink" title="（6） 箭头函数？"></a>（6） 箭头函数？</h5><p>箭头函数没有this,因此也不能绑定。里面的this会指向当前最近的非箭头函数的this，找不到就是window(严格模式是undefined)。比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">do</span> = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.a() <span class="comment">// 找到最近的非箭头函数a，a现在绑定着obj, 因此箭头函数中的this是obj</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>优先级： new &gt; call、apply、bind &gt; 对象.方法 &gt; 直接调用。</p>
</blockquote>
<hr>
<h4 id="27-JS-中-、-、-的用法和含义"><a href="#27-JS-中-、-、-的用法和含义" class="headerlink" title="27. JS 中 ?.、??、??= 的用法和含义"></a>27. <font color="#00AAF0">JS 中 <code>?.</code>、<code>??</code>、<code>??=</code> 的用法和含义</font></h4><h5 id="（1）可选链"><a href="#（1）可选链" class="headerlink" title="（1）可选链(?.)"></a>（1）可选链(?.)</h5><p>如果一个值为null、或者是undefined。那么我们再去用点操作符去调用一个方法或者访问一个属性会发生什么?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="keyword">let</span> b = a.name</span><br></pre></td></tr></table></figure>

<p>如果是上面的这样的代码，那么我们能得到一个报错：</p>
<p><img src="C:%5CUsers%5CF%E4%B8%B6%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221010140457386.png" alt="image-20221010140457386"></p>
<p>其实这种情况就相当于直接在undefined上面访问name属性，undefined和null是两个比较特殊的数据类型，是不能用点操作符去访问属性的。那么在一个变量可能为null、或者undefined的时候，恰巧我又需要访问这个变量的一个属性，那我们应该这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="keyword">let</span> b</span><br><span class="line"><span class="keyword">if</span>(!!a)&#123;</span><br><span class="line">    b = a.name</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    b = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当a存在的时候，我才会去访问a的name属性,如果你想再进一步处理，还可以继续判断以下a的数据类型。可是这不是我们今天的重点，就不多讲了。我们可以看到，这样一个简单的逻辑，我们就要写这么多的东西，那么有没有简单的写法呢？看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="keyword">let</span> b = a?.name</span><br></pre></td></tr></table></figure>

<p>我们终于看到.?这个东西了，其实这个就叫做可选链，表达的意思，就和刚才if else的例子是一个意思，只有当a存在，同时a具有name属性的时候，才会把值赋给b，否则就会将undefined赋值给b。重要的是，不管a存在与否,这么做都不会报错。</p>
<p>当然我们还可以这么干</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="keyword">let</span> b</span><br><span class="line">b = a?.name?.age?.haha?. <span class="comment">//就是不报错</span></span><br><span class="line">a?.b?.c <span class="comment">//(“还是不报错”)</span></span><br></pre></td></tr></table></figure>

<p>我们看到，你后面可以无限接龙下去，不论有多少属性，只要有最后可以访问到属性，访问到最终的结果，就会赋值给b，否则,就把undefined赋值给b。(这样才有资格叫链式结构嘛)</p>
<h5 id="（2）空值合并运算符"><a href="#（2）空值合并运算符" class="headerlink" title="（2）空值合并运算符(??)"></a>（2）空值合并运算符(??)</h5><p>有了上面的例子，接下来我们简单一点，直接上举例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">name</span>:<span class="string">'mybj'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!!a || a === <span class="number">0</span> )&#123;</span><br><span class="line">    b = a</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    b = c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面那个例子，当我们想判断一个值存在，但是它等于0的时候，我们也需要当作它存在，于是就有了上面那样的例子，其实我们还可以这样做:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">name</span>:<span class="string">'mybj'</span> &#125;</span><br><span class="line"></span><br><span class="line">b = a ?? c</span><br></pre></td></tr></table></figure>

<p>上面的例子，当a<strong>除了undefined、或者null之外</strong>的任何值，b都会等于a，否则就等于c。</p>
<h5 id="（3）空值赋值运算符"><a href="#（3）空值赋值运算符" class="headerlink" title="（3）空值赋值运算符(??=)"></a>（3）空值赋值运算符(??=)</h5><p>和上面的例子类似</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="string">'你好'</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="string">'123'</span></span><br><span class="line">b ??= a;  <span class="comment">// b = "你好"</span></span><br><span class="line">c ??= d  <span class="comment">// c = '123'</span></span><br></pre></td></tr></table></figure>

<p>当??=左侧的值为<strong>null、undefined</strong>的时候，才会将右侧变量的值赋值给左侧变量。其他所有值都不会进行赋值。同样在一些场景下，可以省略很多代码。</p>
<hr>
<h4 id="28-实现-JS-重载"><a href="#28-实现-JS-重载" class="headerlink" title="28. 实现 JS 重载"></a>28. <font color="#00AAF0">实现 JS 重载</font></h4><p><strong>什么是重载</strong></p>
<p>我第一次看到<code>重载</code>这个词还是在以前学习<code>Java</code>的时候，我一直觉得<code>JavaScript</code>是没有重载的，直到<code>TypeScript</code>的出现，所以我一直觉得<code>JavaScript</code>没有重载，<code>TypeScript</code>才有，但是现在看来我是错的。</p>
<p>我理解的重载是：同样的函数，不同样的参数个数，执行不同的代码，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 重载</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>,今年<span class="subst">$&#123;age&#125;</span>岁`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name, age, sport</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>,今年<span class="subst">$&#123;age&#125;</span>岁,喜欢运动是<span class="subst">$&#123;sport&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 理想结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fn(<span class="string">'note笔记'</span>) <span class="comment">// 我是note笔记</span></span><br><span class="line">fn(<span class="string">'note笔记'</span>, <span class="number">4</span>) <span class="comment">// 我是note笔记，今年4岁</span></span><br><span class="line">fn(<span class="string">'note笔记'</span>, <span class="number">4</span>, <span class="string">'打篮球'</span>) <span class="comment">// 我是note笔记，今年4岁，喜欢运动是打篮球</span></span><br></pre></td></tr></table></figure>

<p>但是直接在<code>JavaScript</code>中这么写，肯定是不行的，咱们来看看上面代码的实际执行结果，可以看到，最后一个<code>fn</code>的定义，把前面两个都给覆盖了，所以没有实现<code>重载</code>的效果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我是note笔记,今年<span class="literal">undefined</span>岁,喜欢运动是<span class="literal">undefined</span></span><br><span class="line">我是note笔记,今年<span class="number">4</span>岁,喜欢运动是<span class="literal">undefined</span></span><br><span class="line">我是note笔记,今年<span class="number">4</span>岁,喜欢运动是打篮球</span><br></pre></td></tr></table></figure>

<p><strong>我的做法</strong></p>
<p>其实，想要实现理想的<code>重载</code>效果，我还是有办法的，我可以只写一个<code>fn</code>函数，并在这个函数中判断<code>arguments</code>类数组的长度，执行不同的代码，就可以完成<code>重载</code>的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">const</span> [name] = <span class="built_in">arguments</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">const</span> [name, age] = <span class="built_in">arguments</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>,今年<span class="subst">$&#123;age&#125;</span>岁`</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="keyword">const</span> [name, age, sport] = <span class="built_in">arguments</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>,今年<span class="subst">$&#123;age&#125;</span>岁,喜欢运动是<span class="subst">$&#123;sport&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 实现效果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fn(<span class="string">'note笔记'</span>) <span class="comment">// 我是note笔记</span></span><br><span class="line">fn(<span class="string">'note笔记'</span>, <span class="number">4</span>) <span class="comment">// 我是note笔记，今年4岁</span></span><br><span class="line">fn(<span class="string">'note笔记'</span>, <span class="number">4</span>, <span class="string">'打篮球'</span>) <span class="comment">// 我是note笔记，今年4岁，喜欢运动是打篮球</span></span><br></pre></td></tr></table></figure>

<p>但是那位同学说，网易的面试官好像觉得这么实现可以是可以，但是还有没有更好的实现方法，我就懵逼了。</p>
<p><strong>高端做法</strong></p>
<p>经过了我的一通网上查找资料，发现了一种比较高端的做法，可以利用<code>闭包</code>来实现<code>重载</code>的效果。这个方法在JQuery之父John Resig写的《secrets of the JavaScript ninja》中，这种方法充分的利用了<code>闭包</code>的特性！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addMethod</span>(<span class="params">object, name, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> old = object[name] <span class="comment">//把前一次添加的方法存在一个临时变量old里面</span></span><br><span class="line">  object[name] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 重写了object[name]的方法</span></span><br><span class="line">    <span class="comment">// 如果调用object[name]方法时，传入的参数个数跟预期的一致，则直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (fn.length === <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      <span class="comment">// 否则，判断old是否是函数，如果是，就调用old</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> old === <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> old.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addMethod(<span class="built_in">window</span>, <span class="string">'fn'</span>, (name) =&gt; <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>`</span>))</span><br><span class="line">addMethod(<span class="built_in">window</span>, <span class="string">'fn'</span>, (name, age) =&gt; <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>,今年<span class="subst">$&#123;age&#125;</span>岁`</span>))</span><br><span class="line">addMethod(<span class="built_in">window</span>, <span class="string">'fn'</span>, (name, age, sport) =&gt; <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;name&#125;</span>,今年<span class="subst">$&#123;age&#125;</span>岁,喜欢运动是<span class="subst">$&#123;sport&#125;</span>`</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 实现效果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.fn(<span class="string">'note笔记'</span>) <span class="comment">// 我是note笔记</span></span><br><span class="line"><span class="built_in">window</span>.fn(<span class="string">'note笔记'</span>, <span class="number">4</span>) <span class="comment">// 我是note笔记，今年4岁</span></span><br><span class="line"><span class="built_in">window</span>.fn(<span class="string">'note笔记'</span>, <span class="number">4</span>, <span class="string">'打篮球'</span>) <span class="comment">// 我是note笔记，今年4岁，喜欢运动是打篮球</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="29-ES6-解构赋值的实用技巧"><a href="#29-ES6-解构赋值的实用技巧" class="headerlink" title="29. ES6 解构赋值的实用技巧"></a>29. <font color="#00AAF0">ES6 解构赋值的实用技巧</font></h4><h5 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h5><p>为什么需要解构呢，先来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    name: <span class="string">'ZhangSan'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    scores: &#123;</span><br><span class="line">        math: <span class="number">19</span>,</span><br><span class="line">        english: <span class="number">85</span>,</span><br><span class="line">        chinese: <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name:'</span>, student.name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'math:'</span>, student.scores.math);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'english:'</span>, student.scores.english);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'chinese:'</span>, student.scores.chinese);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">displayInfo(student);</span><br></pre></td></tr></table></figure>

<p>这样写也能实现预期效果，但是代码看起来比较冗余。并且，如果对象内部嵌套较深时，那么对象的访问链就会变得很长。虽然这并不是什么大问题，但是使用解构赋值会让代码变得更简单和易读。</p>
<p>下面就来看看什么是解构赋值。MDN 中对解构赋值的描述：</p>
<blockquote>
<p>解构赋值语法是一种 Javascript 表达式。通过解构赋值，可以将属性值从对象/数组中取出，赋值给其他变量。</p>
</blockquote>
<p>实际上，解构赋值就是将复杂的结构分解为简单的部分。解构赋值语法可以用于变量声明或者变量赋值。除此之外，还可以使用嵌套的解构赋值语法来处理嵌套结构。</p>
<p>比如，对上面例子中的对象进行解构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, <span class="attr">scores</span>: &#123;math, english, chinese&#125; &#125; = student; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name:'</span>, name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'math:'</span>, math);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'english:'</span>, english);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'chinese:'</span>, chinese);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看起来是不是简洁多了。</p>
<h5 id="二、解构分类"><a href="#二、解构分类" class="headerlink" title="二、解构分类"></a>二、解构分类</h5><p>根据MDN对解构赋值的定义，我们可以将解构赋值分为两大类：</p>
<ul>
<li>对象解构</li>
<li>数组解构</li>
</ul>
<p>下面就分别来看看这两种解构赋值。</p>
<h6 id="1-对象的解构赋值"><a href="#1-对象的解构赋值" class="headerlink" title="1. 对象的解构赋值"></a>1. 对象的解构赋值</h6><p>对象解构又称为对象属性分配模式，它允许我们将对象的属性值分配给相应的变量。它有两种写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =  &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: a, <span class="attr">y</span>: b, <span class="attr">z</span>: c&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;x, y, z&#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一种（第3行）是对象解构的完整形式，对象的每个属性都将被分配一个变量，其中冒号前面的是源对象中的属性，冒号后面的是要赋值属性;</li>
<li>第二种（第5行）是对象解构的简写形式，对象的属性与要分配的属性一致时可以使用这种形式。</li>
</ul>
<p>如果需要给已有变量赋值，就需要额外注意了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =  &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">(&#123;x, y, z&#125; = obj)</span><br><span class="line"><span class="built_in">console</span>.log(x, y, z)</span><br></pre></td></tr></table></figure>

<p>这里需要注意，需要将赋值表达式使用括号括起来，如果省略，解构对象将被视为一个块语句，而块语句是不能放在赋值表达式左侧的。</p>
<p>当使用解构赋值时，可以给变量传递一个默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'ZhangSan'</span>,</span><br><span class="line">    height: <span class="number">180</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; name, height, age = <span class="number">25</span> &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name, height, age);</span><br></pre></td></tr></table></figure>

<p>这里我们给age分配了一个默认值，当对源对象上不存在age属性时，age就会被赋上默认值25，而不是undefined。</p>
<p>如果分配的对象属性为undefined，那么就会使用默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;x = <span class="number">2</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x);    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h6 id="2-数组的解构赋值"><a href="#2-数组的解构赋值" class="headerlink" title="2. 数组的解构赋值"></a>2. 数组的解构赋值</h6><p>在使用数组解构时，实际上会使用迭代器将所需要的值与结构源分开。因此，我们可以对<strong>可迭代值</strong>使用数组结构，包括字符串、数组、集合、函数映射、DOM元素。我们还可以将解构赋值与扩展运算符结合使用。</p>
<p>（1）字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="keyword">let</span> [a, b] = message;</span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = message;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b);        <span class="comment">// H e</span></span><br><span class="line"><span class="built_in">console</span>.log(x, y, z);     <span class="comment">// H e ['l', 'l', 'o']</span></span><br></pre></td></tr></table></figure>

<p>（2）数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [x, y, z] = numbers;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x, y, z);    <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<p>（3）集合</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set().add('foo').add('bar');</span><br><span class="line">let [a, b] = <span class="keyword">set</span>;</span><br><span class="line"></span><br><span class="line">console.log(a, b);      // foo bar</span><br></pre></td></tr></table></figure>

<p>（4）Map</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'a'</span>, <span class="number">1</span>).set(<span class="string">'b'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">let</span> [x, y] = map;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x, y);    <span class="comment">// ["a", 1] ["b", 2]</span></span><br></pre></td></tr></table></figure>

<p>在数组的解构中，存储变量的数组中的每个变量都会映射到解构数组上相同索引处的相应项。</p>
<p>如果解构中某一项不需要，可以使用逗号操作符进行分隔：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rgb = [<span class="number">200</span>, <span class="number">255</span>, <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [,, blue] = rgb;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(blue);   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>与对象解构一样，可以使用数组解构为局部变量设置默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rgb = [<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [red = <span class="number">255</span>, green, blue = <span class="number">255</span>] = rgb;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`R: <span class="subst">$&#123;red&#125;</span>, G: <span class="subst">$&#123;green&#125;</span>, B: <span class="subst">$&#123;blue&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>如果变量已经存在，就可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> red = <span class="number">100</span>, green = <span class="number">200</span>, blue = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rgb = [<span class="number">200</span>, <span class="number">255</span>, <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">[red, green] = rgb;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`R: <span class="subst">$&#123;red&#125;</span>, G: <span class="subst">$&#123;green&#125;</span>, B: <span class="subst">$&#123;blue&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>与对象解构不同的是，这里不需要括号将数组括起来。</p>
<p>如果给变量分配的值是undefined，那么就会使用默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line"><span class="built_in">console</span>.log(x);    <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这里的默认值并不一定是一个固定值，它可以是一个计算属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">x</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;x=foo()&#125; = obj1;</span><br><span class="line"><span class="built_in">console</span>.log(x);     <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;x=foo()&#125; = obj2;</span><br><span class="line"><span class="built_in">console</span>.log(x);     <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>如果我们想将数组中的一些元素分配给变量，而将数组中的其余项分配给特定的变量就可以这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [greeting,...intro] = [<span class="string">"Hello"</span>, <span class="string">"I"</span> , <span class="string">"am"</span>, <span class="string">"CUGGZ"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(greeting);  <span class="comment">// "Hello"</span></span><br><span class="line"><span class="built_in">console</span>.log(intro);     <span class="comment">// ["I", "am", "CUGGZ"]</span></span><br></pre></td></tr></table></figure>

<h5 id="三、嵌套解构"><a href="#三、嵌套解构" class="headerlink" title="三、嵌套解构"></a>三、嵌套解构</h5><p>上面我们说的解构的只是普通的数组和对象。实际上，解构赋值可以用于嵌套数组和嵌套对象。比如，文章最开始的例子中，就是解构的嵌套对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = &#123;</span><br><span class="line">    name: <span class="string">'ZhangSan'</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    scores: &#123;</span><br><span class="line">        math: <span class="number">19</span>,</span><br><span class="line">        english: <span class="number">85</span>,</span><br><span class="line">        chinese: <span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; name, <span class="attr">scores</span>: &#123;math, english, chinese&#125; &#125; = student;</span><br></pre></td></tr></table></figure>

<p>再来看一个嵌套数组解构的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> [a, [b, c, d], e] = numbers;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d, e); <span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>

<h5 id="四、使用技巧"><a href="#四、使用技巧" class="headerlink" title="四、使用技巧"></a>四、使用技巧</h5><h6 id="1-函数解构"><a href="#1-函数解构" class="headerlink" title="1. 函数解构"></a>1. 函数解构</h6><p>（1）解构函数参数</p>
<p>可以对函数参数使用解构赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">[a, b]</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line">foo([<span class="number">1</span>, <span class="number">2</span>]);       <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">&#123;x, y&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;); <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

<p>可以对函数返回值使用解构赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStudentInfo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">'ZhangSan'</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        scores: &#123;</span><br><span class="line">            math: <span class="number">19</span>,</span><br><span class="line">            english: <span class="number">85</span>,</span><br><span class="line">            chinese: <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name, <span class="attr">scores</span>: &#123;math, english, chinese&#125; &#125; = getStudentInfo();</span><br><span class="line"><span class="built_in">console</span>.log(name, math, english, chinese);</span><br></pre></td></tr></table></figure>

<h6 id="2-循环中的解构"><a href="#2-循环中的解构" class="headerlink" title="2. 循环中的解构"></a>2. 循环中的解构</h6><p>当我们需要循环中的对象键值时，也可以使用对象解构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> students = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'ZhangSan'</span>,</span><br><span class="line">        <span class="string">'grade'</span>: <span class="number">80</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'LiSi'</span>,</span><br><span class="line">        <span class="string">'grade'</span>: <span class="number">75</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'WangWu'</span>,</span><br><span class="line">        <span class="string">'grade'</span>: <span class="number">95</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> &#123;name, grade&#125; <span class="keyword">of</span> students)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name, grade);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-动态属性解构"><a href="#3-动态属性解构" class="headerlink" title="3. 动态属性解构"></a>3. 动态属性解构</h6><p>很多时候我们不知道对象属性的key，只有运行时才知道。比如有一个方法getStudentInfo，它以一个key为参数，并返回相应的属性值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getStudentInfo(<span class="string">'name'</span>); </span><br><span class="line">getStudentInfo(<span class="string">'age'</span>);</span><br></pre></td></tr></table></figure>

<p>这里传递给getStudentInfo方法的参数是动态的，因此可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getStudentInfo = <span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;[key]: value&#125; = student;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，包裹key的方括号不能少，否则会出现undefined值。</p>
<h6 id="4-交换变量"><a href="#4-交换变量" class="headerlink" title="4. 交换变量"></a>4. 交换变量</h6><p>数组结构一个很实用的功能就是实现交换局部变量。通常，我们会借助临时变量来实现变量的交换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> width = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">let</span> height = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> temp = width;</span><br><span class="line">width = height;</span><br><span class="line">height = temp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(width, height)</span><br></pre></td></tr></table></figure>

<p>如果使用数组的解构赋值，就会变得很简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> width = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">let</span> height = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">[width, height] = [height, width];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(width, height)</span><br></pre></td></tr></table></figure>

<h6 id="5-数组拷贝"><a href="#5-数组拷贝" class="headerlink" title="5. 数组拷贝"></a>5. 数组拷贝</h6><p>可以使用解构赋值和rest运算符来实现数组的拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rgb = [<span class="number">200</span>, <span class="number">255</span>, <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [...newRgb] = rgb;</span><br><span class="line"><span class="comment">// 等同于 const newRgb = [...rgb]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newRgb)</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="30-CSS实现带箭头的提示框"><a href="#30-CSS实现带箭头的提示框" class="headerlink" title="30. CSS实现带箭头的提示框"></a>30. <font color="#00AAF0">CSS实现带箭头的提示框</font></h4><p>我们在很多UI框架中看到带箭头的提示框，感觉挺漂亮，但是之前一直不知道其原理，今天网上找了些资料算是弄清楚原理了；</p>
<p>先上效果图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201910/1650307-20191014160745847-311614677.png" alt="img"></p>
<p>原理分析：</p>
<p>  上面的箭头有没有觉得很像一个三角形，是的，它就是三角形；只不过它这个尖角是通过两个三角形来实现的；</p>
<p>首先新建一个div，画出提示框的轮廓</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>给定样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">35%</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">40%</span>;   </span><br><span class="line">  <span class="attribute">border</span>:<span class="number">2px</span> solid red;</span><br><span class="line">  <span class="attribute">border-radius</span>:<span class="number">8px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这样，我们简单的一个正方形提示框就出来；</p>
<p>关键点：</p>
<p>  现在我们在class=“demo”的div里面加入一个子级元素div</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"shixin"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>

<p>添加样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shixin</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">100px</span> solid ;</span><br><span class="line">  <span class="attribute">border-color</span>:red green yellow blue;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">21%</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">15%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>宽高都设为0；然后设置一个边框的宽度，暂且设为100，边框颜色自己设定；此时的应该是一个200*200的正方形，因为上下边框相加为200px；左右边框相加为200px；</p>
<p>效果图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201910/1650307-20191014161012932-1910070530.png" alt="img"></p>
<p>然后我们现在只需要它的下面（下面的三角形）的一部分；</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shixin</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>:red;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">21%</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">15%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>切记：border属性的颜色一定要写为transparent（透明），不然默认为黑色；然后我们需要下面的三角形，我们只需要用border-bottom-color属性给下边框添加颜色即可称为实心三角形；</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201910/1650307-20191014161056659-489428628.png" alt="img"></p>
<p>然后我们适当的调整一下大小，三角形的大小是通过border的宽度来调的，因为这个其实就是border的宽度；</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201910/1650307-20191014161113569-524300876.png" alt="img"></p>
<p>就这样，一个实心的三角形提示框效果已经出来了，但是别人UI框架都是空心的啊，没关系，我们接着往下走：</p>
<p>在class=”demo”的div下面再加一个div</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"demo"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"shixin"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;div class="kongxin"&gt;&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加样式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.kongxin</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">10px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom-color</span>:<span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">39%</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">15%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看到了吗？我们给这个三角形也是添加一样的样式，实现空心效果其实就是将三角形的颜色改为背景色，背景默认为白色，然后通过position：relative相对定位移到实心三角形处进行重合即可；</p>
<p><img src="https://img2018.cnblogs.com/blog/1650307/201910/1650307-20191014161227305-932108410.png" alt="img"></p>
<hr>
<h4 id="31-8种Vue中数据更新了但页面没有更新的情况"><a href="#31-8种Vue中数据更新了但页面没有更新的情况" class="headerlink" title="31.  8种Vue中数据更新了但页面没有更新的情况"></a>31.  <font color="#00AAF0">8种Vue中数据更新了但页面没有更新的情况</font></h4><h5 id="①-Vue-无法检测实例被创建时不存在于-data-中的-属性"><a href="#①-Vue-无法检测实例被创建时不存在于-data-中的-属性" class="headerlink" title="①  Vue 无法检测实例被创建时不存在于 data 中的 属性"></a>①  Vue 无法检测实例被创建时不存在于 data 中的 属性</h5><p><strong>原因：</strong><br>由于 Vue 会在初始化实例时对 属性 执行 getter/setter 转化<br>所以 属性 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>
<p><strong>场景</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 页面不会变化</span></span><br><span class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line">vm.message = <span class="string">'Hello!'</span> <span class="comment">// `vm.message` 不是响应式的</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="comment">// 声明 a、b 为一个空值字符串</span></span><br><span class="line">    message: <span class="string">''</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line">vm.message = <span class="string">'Hello!'</span></span><br></pre></td></tr></table></figure>

<p><strong>扩展: VUE组件中的data必须是函数？</strong><br>Object是引用数据类型，如果不用function返回，每个组件的data都是内存的同一个地址，一个数据改变了其他也改变了。<br>只有函数构成作用域(注意理解作用域，只有函数{}构成作用域,对象的{}以及<code>if(){}</code>都不构成作用域),data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。</p>
<h5 id="②-Vue-无法检测‘对象属性’的添加或移除"><a href="#②-Vue-无法检测‘对象属性’的添加或移除" class="headerlink" title="② Vue 无法检测‘对象属性’的添加或移除"></a>② Vue 无法检测‘对象属性’的添加或移除</h5><p><strong>原因：</strong><br>由于ES5的限制，Vue.js 不能检测到对象属性的添加或删除。<br>因为 Vue.js 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue.js 转换它，才能让它是响应的。<br><strong>场景：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">      id: <span class="number">001</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 页面不会变化</span></span><br><span class="line">  template: <span class="string">'&lt;div&gt;&#123;&#123; obj.message &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.obj.message = <span class="string">'hello'</span> <span class="comment">// 不是响应式的</span></span><br><span class="line"><span class="keyword">delete</span> vm.obj.id       <span class="comment">// 不是非响应式的</span></span><br></pre></td></tr></table></figure>

<p><strong>解决办法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态添加 - Vue.set</span></span><br><span class="line">Vue.set(vm.obj, propertyName, newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态添加 - vm.$set</span></span><br><span class="line">vm.$<span class="keyword">set</span>(vm.obj, propertyName, newValue)</span><br><span class="line"></span><br><span class="line">// 动态添加多个 </span><br><span class="line">// 代替 `Object.assign(this.obj, &#123; a: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)<span class="string">`</span></span><br><span class="line"><span class="string">this.obj = Object.assign(&#123;&#125;, this.obj, &#123; a: 1, b: 2 &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 动态移除 - Vue.delete</span></span><br><span class="line"><span class="string">Vue.delete(vm.obj, propertyName)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 动态移除 - vm.$delete</span></span><br><span class="line"><span class="string">vm.$delete(vm.obj, propertyName)</span></span><br></pre></td></tr></table></figure>



<h5 id="③-Vue-不能检测利用数组索引直接修改一个数组项"><a href="#③-Vue-不能检测利用数组索引直接修改一个数组项" class="headerlink" title="③ Vue 不能检测利用数组索引直接修改一个数组项"></a>③ Vue 不能检测利用数组索引直接修改一个数组项</h5><p><strong>原因：</strong><br>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化；尤雨溪 - 性能代价和获得用户体验不成正比。</p>
<p><strong>场景：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">'x'</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure>

<p><strong>解决办法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// vm.$set</span></span><br><span class="line">vm.$<span class="keyword">set</span>(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure>

<p><strong>拓展：</strong><br><strong>Object.defineProperty() 可以监测数组的变化</strong><br>对数组新增一个属性（index）不会监测到数据变化，因为无法监测到新增数组的下标（index），删除一个属性（index）也是。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(arr, index, &#123;</span><br><span class="line">    <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'触发 setter'</span>)</span><br><span class="line">      item = value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>: function() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'触发 getter'</span>)</span><br><span class="line">      <span class="keyword">return</span> item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">'123'</span>  <span class="comment">// 触发 setter</span></span><br><span class="line">arr[<span class="number">1</span>]          <span class="comment">// 触发 getter 返回值为 "123"</span></span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">5</span>      <span class="comment">// 不会触发 setter 和 getter</span></span><br></pre></td></tr></table></figure>



<h5 id="④-Vue-不能监测直接修改数组长度的变化"><a href="#④-Vue-不能监测直接修改数组长度的变化" class="headerlink" title="④ Vue 不能监测直接修改数组长度的变化"></a>④ Vue 不能监测直接修改数组长度的变化</h5><p><strong>原因：</strong><br>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化；<br>尤雨溪 - 性能代价和获得用户体验不成正比。(Object.defineProperty() 可以监测数据的变化)<br><strong>场景：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items.length = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure>

<p><strong>解决办法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>



<h5 id="⑤-在异步更新执行之前操作-DOM-数据不会变化"><a href="#⑤-在异步更新执行之前操作-DOM-数据不会变化" class="headerlink" title="⑤ 在异步更新执行之前操作 DOM 数据不会变化"></a>⑤ 在异步更新执行之前操作 DOM 数据不会变化</h5><p><strong>原因：</strong><br>由于Vue 在更新 DOM 时是异步执行的。<br>只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。<br>如果同一个 watcher 被多次触发，只会被推入到队列中一次。<br>这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。<br>然后，在下一个的事件循环中，Vue 刷新队列并执行实际 (已去重的) 工作。<br>Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p>
<p><strong>场景：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"example"</span>&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#example',</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    message: '123'</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">vm.message = 'new message' /</span><span class="regexp">/ 更改数据</span></span><br><span class="line"><span class="regexp">vm.$el.textContent === 'new message' /</span><span class="regexp">/ false</span></span><br><span class="line"><span class="regexp">vm.$el.style.color = 'red' /</span><span class="regexp">/ 页面没有变化</span></span><br></pre></td></tr></table></figure>

<p><strong>解决办法：</strong><br>使用 <code>Vue.nextTick(callback)</code> callback 将在 DOM 更新完成后被调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'123'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.message = <span class="string">'new message'</span> <span class="comment">// 更改数据</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  vm.$el.textContent === <span class="string">'new message'</span> <span class="comment">// true</span></span><br><span class="line">  vm.$el.style.color = <span class="string">'red'</span> <span class="comment">// 文字颜色变成红色</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>拓展：</strong><br><strong>异步更新带来的数据响应的误解</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面显示：我更新啦！ --&gt;</span><br><span class="line">&lt;div id=<span class="string">"example"</span>&gt;&#123;&#123;message.text&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#example',</span></span><br><span class="line"><span class="regexp">  data: &#123;</span></span><br><span class="line"><span class="regexp">    message: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">vm.$nextTick(function () &#123;</span></span><br><span class="line"><span class="regexp">  this.message = &#123;&#125;</span></span><br><span class="line"><span class="regexp">  this.message.text = '我更新啦！'</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure>

<p>上段代码中，我们在 data 对象中声明了一个 message 空对象，然后在下次 DOM 更新循环结束之后触发的异步回调中，执行了如下两段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.message = &#123;&#125;;</span><br><span class="line"><span class="keyword">this</span>.message.text = <span class="string">'我更新啦！'</span></span><br></pre></td></tr></table></figure>

<p>到这里，模版更新了，页面最后会显示 我更新啦！。<br>模板更新了，应该具有响应式特性，如果这么想那么你就已经走入了误区。<br>一开始我们在 data 对象中只是声明了一个 message 空对象，并不具有 text 属性，所以该 text 属性是不具有响应式特性的。</p>
<p><strong>但模板切切实实已经更新了，这又是怎么回事呢？</strong></p>
<p>那是因为 Vue.js 的 DOM 更新是异步的，即当 setter 操作发生后，指令并不会立马更新，指令的更新操作<strong>会有一个延迟</strong>，当指令更新真正执行的时候，此时 text 属性已经赋值，所以指令更新模板时得到的是新值。</p>
<blockquote>
<p>模板中每个指令/数据绑定都有一个对应的 watcher 对象，在计算过程中它把属性记录为依赖。之后当依赖的 setter 被调用时，会触发 watcher 重新计算 ，也就会导致它的关联指令更新 DOM。</p>
</blockquote>
<p><strong>具体流程如下所示：</strong></p>
<ul>
<li>执行 <code>this.dataObj = {};</code> 时， setter 被调用。</li>
<li>Vue.js 追踪到 message 依赖的 setter 被调用后，会触发 watcher 重新计算。</li>
<li><code>this.message.text = &#39;new text&#39;</code>; 对 text 属性进行赋值。</li>
<li>异步回调逻辑执行结束之后，就会导致它的关联指令更新 DOM，指令更新开始执行。</li>
</ul>
<p>所以真正的触发模版更新的操作是 this.message = {};这一句引起的，因为触发了 setter，所以单看上述例子，具有响应式特性的数据只有 message 这一层，它的动态添加的属性是不具备的。</p>
<blockquote>
<p>对应上述第二点 - Vue 无法检测对象 property 的添加或移除</p>
</blockquote>
<h5 id="⑥-循环嵌套层级太深，视图不更新"><a href="#⑥-循环嵌套层级太深，视图不更新" class="headerlink" title="⑥ 循环嵌套层级太深，视图不更新"></a>⑥ 循环嵌套层级太深，视图不更新</h5><p>看到网上有些人说数据更新的层级太深，导致数据不更新或者更新缓慢从而导致试图不更新？</p>
<p>由于我没有遇到过这种情况，在我试图重现这种场景的情况下，发现并没有上述情况的发生，所以对于这一点不进行过多描述（如果有人在真实场景下遇到这种情况留个言吧）。</p>
<p>针对上述情况有人给出的解决方案是使用强制更新：</p>
<blockquote>
<p>如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。<br>迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
</blockquote>
<ol>
<li>不会重新触发生命周期钩子函数，比如mounted</li>
<li>不会渲染子组件的更新，即使子组件的props发生改变了。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$forceUpdate()</span><br></pre></td></tr></table></figure>



<h5 id="⑦-路由参数变化时，页面不更新（数据不更新）"><a href="#⑦-路由参数变化时，页面不更新（数据不更新）" class="headerlink" title="⑦ 路由参数变化时，页面不更新（数据不更新）"></a>⑦ 路由参数变化时，页面不更新（数据不更新）</h5><p><strong>原因：</strong><br>路由视图组件引用了相同组件时，当路由参会变化时，会导致该组件无法更新，也就是我们常说中的页面无法更新的问题。</p>
<p><strong>场景：</strong><br>在路由构建选项 routes 中配置了一个动态路由 ‘/home/:name’，它们共用一个路由组件 Home，这代表他们复用 RouterView 。<br>当进行路由切换时，页面只会渲染第一次路由匹配到的参数，之后再进行路由切换时，message 是没有变化的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/home/foo"</span>&gt;</span>To Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span>&lt;<span class="regexp">/li&gt; </span></span><br><span class="line"><span class="regexp">    &lt;li&gt;&lt;router-link to="/</span>home/baz<span class="string">"&gt;To Baz&lt;/router-link&gt;&lt;/li&gt; </span></span><br><span class="line"><span class="string">    &lt;li&gt;&lt;router-link to="</span>/home/bar<span class="string">"&gt;To Bar&lt;/router-link&gt;&lt;/li&gt; </span></span><br><span class="line"><span class="string">  &lt;/ul&gt; </span></span><br><span class="line"><span class="string">  &lt;router-view&gt;&lt;/router-view&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const Home = &#123;</span></span><br><span class="line"><span class="string">  template: `&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;`,</span></span><br><span class="line"><span class="string">  data() &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      message: this.$route.params.name</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const router = new VueRouter(&#123;</span></span><br><span class="line"><span class="string">  mode:'history',</span></span><br><span class="line"><span class="string"> routes: [</span></span><br><span class="line"><span class="string">    &#123;path: '/home', component: Home &#125;,</span></span><br><span class="line"><span class="string">    &#123;path: '/home/:name', component: Home &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">new Vue(&#123;</span></span><br><span class="line"><span class="string">  el: '#app',</span></span><br><span class="line"><span class="string">  router</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>解决办法：</strong></p>
<p>解决的办法有很多种，这里只列举我常用到一种方法。</p>
<p>通过 watch 监听 $route 的变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="keyword">this</span>.$route.params.name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">   <span class="string">'$route'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = <span class="keyword">this</span>.$route.params.name</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>给 <code>&lt;router-view&gt;&lt;/router-view&gt;</code> 绑定 key 属性，这样 Vue 就会认为这是不同的<code>&lt;router-view&gt;</code>。<br>弊端：如果从 /home 跳转到 /user 等其他路由下，我们是不用担心组件更新问题的，所以这个时候 key 属性是多余的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;router-view :key=<span class="string">"key"</span>&gt;&lt;<span class="regexp">/router-view&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>



<h5 id="⑧-使用keep-alive之后数据无法实时更新问题"><a href="#⑧-使用keep-alive之后数据无法实时更新问题" class="headerlink" title="⑧ 使用keep-alive之后数据无法实时更新问题"></a>⑧ 使用keep-alive之后数据无法实时更新问题</h5><p><strong>keep-alive 相关内容</strong><br><strong>概念：</strong> <code>&lt;keep-alive&gt;</code> 是Vue的一个内部组件，适合用来缓存不需要实时更新的组件，这样可以保留组件状态避免重新渲染。<br><strong>Props：</strong></p>
<ul>
<li>include ：接受字符串或正则表达式，这里是需要被缓存的组件名</li>
<li>exclude ：接受字符串或正则表达式，这里是不需要缓存的组件名</li>
<li>max ：接受数字，最多可以缓存多少组件实例</li>
</ul>
<p><strong>问题描述：</strong><br>问题： 在需要重新请求数据的时候，依然走的缓存<br>根据需求实现在列表页点击“编辑”进行修改某项数据，修改完成返回之后，依旧保留在原位置，保留之前的查找条件和之前的数据，使用vue中的<code>&lt;keep-alive&gt;</code>之后，返回列表页时不刷新页面，依旧保持之前的数据，无法展示修改之后的最新消息。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li><p>方案1： 如果要在进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务(亲测，时而有效，时而无效，不知道是什么原因)。</p>
</li>
<li><p>方案2： 在账户登录之后调用 *<em>window.location.reload() *</em>，起到重新请求的作用（已亲测）</p>
</li>
<li><p>方案3： 在vuex中设置状态，动态绑定 include 值，在登录的时候缓存需要缓存的组件，在退出的时候，清除需要刷新的组件（效果很理想，也顺带解决了加载数据时，数据闪现的情况）</p>
</li>
<li><p>方案4：借用组件内的守卫<code>beforeRouteEnter(to,from,next){},</code>方法，</p>
<blockquote>
<p>每次进入之后取到编辑之后的最新数据，然后把现有的列表中对应的数据进行修改，修改之后进行强制刷新，这样就可以实现需要的效果了。</p>
</blockquote>
<p>beforeRouteEnter 守卫不能访问 this：因为守卫在导航确认前被调用,因此即将登场的新组件还没被创建。</p>
<p>　不过，你可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。　</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>注意:</strong><br>beforeRouteEnter 是支持给 next 传递回调的唯一守卫。<br>对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以不支持传递回调，因为没有必要了。</p>
<hr>
<h4 id="32-ES6-Array-from-详解"><a href="#32-ES6-Array-from-详解" class="headerlink" title="32. ES6 Array.from() 详解"></a>32. <font color="#00AFF0"><strong>ES6 <code>Array.from()</code> 详解</strong></font></h4><p><strong><code>Array.from()</code></strong> 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a><strong>语法</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, (element) =&gt; &#123; <span class="comment">/* … */</span> &#125; )</span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, (element, index) =&gt; &#123; <span class="comment">/* … */</span> &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 映射函数</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, mapFn)</span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, mapFn, thisArg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联映射函数</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="keyword">function</span> <span class="title">mapFn</span>(<span class="params">element</span>) </span>&#123; <span class="comment">/* … */</span> &#125;)</span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="keyword">function</span> <span class="title">mapFn</span>(<span class="params">element, index</span>) </span>&#123; <span class="comment">/* … */</span> &#125;)</span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="keyword">function</span> <span class="title">mapFn</span>(<span class="params">element</span>) </span>&#123; <span class="comment">/* … */</span> &#125;, thisArg)</span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="keyword">function</span> <span class="title">mapFn</span>(<span class="params">element, index</span>) </span>&#123; <span class="comment">/* … */</span> &#125;, thisArg)</span><br></pre></td></tr></table></figure>

<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a><strong>参数</strong></h5><ul>
<li><code>arrayLike</code></li>
</ul>
<p>​        想要转换成数组的伪数组对象或可迭代对象。</p>
<ul>
<li><p><code>mapFn</code> 可选</p>
<p>如果指定了该参数，新数组中的每个元素会执行该回调函数。</p>
</li>
<li><p><code>thisArg</code> 可选</p>
<p>可选参数，执行回调函数 <code>mapFn</code> 时 <code>this</code> 对象。</p>
</li>
</ul>
<h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a><strong>返回值</strong></h5><p>一个新的数组实例。</p>
<h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a><font color="blue"><strong>描述</strong></font></h5><p><code>Array.from()</code> 可以通过以下方式来创建数组对象：</p>
<ul>
<li>伪数组对象（拥有一个 <code>length</code> 属性和若干索引属性的任意对象）</li>
<li>可迭代对象（可以获取对象中的元素，如 Map 和 Set 等）</li>
</ul>
<p><code>Array.from()</code> 方法有一个可选参数 <code>mapFn</code>，让你可以在最后生成的数组上再执行一次 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener"><code>map</code></a> 方法后再返回。也就是说 <code>Array.from(obj, mapFn, thisArg)</code> 就相当于 <code>Array.from(obj).map(mapFn, thisArg)</code>, 除非创建的不是可用的中间数组。这对一些数组的子类 <code>,</code> 如 typed arrays来说很重要，因为中间数组的值在调用 map() 时需要是适当的类型。</p>
<p><code>from()</code> 的 <code>length</code> 属性为 1，即 <code>Array.from.length === 1</code>。</p>
<p>在 ES2015 中， <code>Class</code> 语法允许我们为内置类型（比如 <code>Array</code>）和自定义类新建子类（比如叫 <code>SubArray</code>）。这些子类也会继承父类的静态方法，比如 <code>SubArray.from()</code>，调用该方法后会返回子类 <code>SubArray</code> 的一个实例，而不是 <code>Array</code> 的实例。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h5><h6 id="1-从-String-生成数组"><a href="#1-从-String-生成数组" class="headerlink" title="(1) 从 String 生成数组"></a>(1) 从 <code>String</code> 生成数组</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// [ "f", "o", "o" ]</span></span><br></pre></td></tr></table></figure>



<h6 id="2-从-Set-生成数组"><a href="#2-从-Set-生成数组" class="headerlink" title="(2) 从 Set 生成数组"></a>(2) 从 <code>Set</code> 生成数组</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set(['foo', 'bar', 'baz', 'foo'])</span><br><span class="line">Array.from(<span class="keyword">set</span>)</span><br><span class="line">// [ "foo", "bar", "baz" ]</span><br></pre></td></tr></table></figure>



<h6 id="3-从-Map-生成数组"><a href="#3-从-Map-生成数组" class="headerlink" title="(3) 从 Map 生成数组"></a>(3) 从 <code>Map</code> 生成数组</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">8</span>]])</span><br><span class="line"><span class="built_in">Array</span>.from(map)</span><br><span class="line"><span class="comment">// [[1, 2], [2, 4], [4, 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapper = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'1'</span>, <span class="string">'a'</span>], [<span class="string">'2'</span>, <span class="string">'b'</span>]])</span><br><span class="line"><span class="built_in">Array</span>.from(mapper.values())</span><br><span class="line"><span class="comment">// ['a', 'b']</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(mapper.keys())</span><br><span class="line"><span class="comment">// ['1', '2']</span></span><br></pre></td></tr></table></figure>



<h6 id="4-从类数组对象（arguments）生成数组"><a href="#4-从类数组对象（arguments）生成数组" class="headerlink" title="(4) 从类数组对象（arguments）生成数组"></a>(4) 从类数组对象（arguments）生成数组</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>



<h6 id="5-在-Array-from-中使用箭头函数"><a href="#5-在-Array-from-中使用箭头函数" class="headerlink" title="(5) 在 Array.from 中使用箭头函数"></a>(5) 在 <code>Array.from</code> 中使用箭头函数</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using an arrow function as the map function to</span></span><br><span class="line"><span class="comment">// manipulate the elements</span></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x + x)</span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate a sequence of numbers</span></span><br><span class="line"><span class="comment">// Since the array is initialized with `undefined` on each position,</span></span><br><span class="line"><span class="comment">// the value of `v` below will be `undefined`</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">5</span>&#125;, (v, i) =&gt; i)</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">`Array.from(Array(数组length), (v, k) =&gt; k)`</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="built_in">Array</span>(<span class="number">10</span>), (v, k) =&gt; k)</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>



<h6 id="6-序列生成器-指定范围"><a href="#6-序列生成器-指定范围" class="headerlink" title="(6) 序列生成器 (指定范围)"></a>(6) 序列生成器 (指定范围)</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sequence generator function (commonly referred to as "range", e.g. Clojure, PHP etc)</span></span><br><span class="line"><span class="keyword">const</span> range = <span class="function">(<span class="params">start, stop, step</span>) =&gt;</span> <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="function">(<span class="params">stop - start</span>) / <span class="params">step</span> + 1&#125;, (<span class="params">_, i</span>) =&gt;</span> start + (i * step))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate numbers range 0..4</span></span><br><span class="line">range(<span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate numbers range 1..10 with step of 2</span></span><br><span class="line">range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 3, 5, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the alphabet using Array.from making use of it being ordered as a sequence</span></span><br><span class="line">range(<span class="string">'A'</span>.charCodeAt(<span class="number">0</span>), <span class="string">'Z'</span>.charCodeAt(<span class="number">0</span>), <span class="number">1</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">String</span>.fromCharCode(x))</span><br><span class="line"><span class="comment">// ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]</span></span><br></pre></td></tr></table></figure>



<h6 id="7-数组去重合并"><a href="#7-数组去重合并" class="headerlink" title="(7) 数组去重合并"></a>(7) 数组去重合并</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">combine</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [].concat.apply([], <span class="built_in">arguments</span>)  <span class="comment">//没有去重复的新数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], n = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(combine(m,n))                     <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="33-JS数组转化为对象"><a href="#33-JS数组转化为对象" class="headerlink" title="33. JS数组转化为对象"></a>33. <font color="#00AAF0">JS数组转化为对象</font></h4><h5 id="①-利用Object-fromEntries-与map-方法："><a href="#①-利用Object-fromEntries-与map-方法：" class="headerlink" title="① 利用Object.fromEntries()与map()方法："></a>① 利用<code>Object.fromEntries()</code>与<code>map()</code>方法：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">'小红'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">key</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'小名'</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// eg1:</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(arr.map(<span class="function"><span class="params">item</span> =&gt;</span> [item.key, item]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		0: &#123; key: 0, name: '小红'&#125;,</span></span><br><span class="line"><span class="comment">//		1: &#123; key: 1, name: '小名'&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// eg2:</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(arr.map(<span class="function"><span class="params">item</span> =&gt;</span> [item.key, &#123; <span class="attr">key</span>: item.key, <span class="attr">value</span>: item.name &#125;]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		0: &#123; key: 0, value: '小红'&#125;,</span></span><br><span class="line"><span class="comment">//		1: &#123; key: 1, value: '小名'&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="②-利用扩展运算符"><a href="#②-利用扩展运算符" class="headerlink" title="② 利用扩展运算符..."></a>② 利用扩展运算符<code>...</code></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; ...arr &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">//	&#123;</span></span><br><span class="line"><span class="comment">//		0: &#123; key: 0, name: '小红'&#125;,</span></span><br><span class="line"><span class="comment">//		1: &#123; key: 1, name: '小名'&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="34-CSS设置text从第二行开始缩进："><a href="#34-CSS设置text从第二行开始缩进：" class="headerlink" title="34. CSS设置text从第二行开始缩进："></a>34. <font color="#00AAF0">CSS设置text从第二行开始缩进：</font></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">margin-left</span>: 32<span class="selector-tag">rpx</span>;</span><br><span class="line"><span class="selector-tag">text-indent</span>: <span class="selector-tag">-1</span><span class="selector-class">.4em</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="35-CSS-SASS-SCSS-中的变量的使用注意点："><a href="#35-CSS-SASS-SCSS-中的变量的使用注意点：" class="headerlink" title="35. CSS SASS(SCSS)中的变量的使用注意点："></a>35. <font color="#00AAF0">CSS SASS(SCSS)中的变量的使用注意点：</font></h4><p>① 直接使用：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$custom-size</span>: <span class="number">16</span>rpx;</span><br><span class="line"><span class="selector-class">.page</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$custom-size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>② 在计算中使用：</p>
<p><font color="blue">需要使用 <code>#{变量}</code> 来解析变量，否则无效。</font></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$custom-size</span>: <span class="number">16</span>rpx;</span><br><span class="line"><span class="selector-class">.page</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: calc(<span class="number">100%</span> - #&#123;<span class="variable">$custom-size</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="0-共勉："><a href="#0-共勉：" class="headerlink" title="0. 共勉："></a>0. <font color="#00AFF0"><strong>共勉：</strong></font></h4>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/note/2022/08/10/Python/" rel="next" title="Python">
                <i class="fa fa-chevron-left"></i> Python
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/note/2022/09/13/JS%20CSS%20utils/" rel="prev" title="JS CSS utils">
                JS CSS utils <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/note/images/dog.jpg"
                alt="F゛" />
            
              <p class="site-author-name" itemprop="name">F゛</p>
              <p class="site-description motion-element" itemprop="description">study hard and make progress every day!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/note/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-JS-垃圾回收机制："><span class="nav-number">1.</span> <span class="nav-text">1. JS 垃圾回收机制：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内存泄漏和内存回收机制"><span class="nav-number">1.1.</span> <span class="nav-text">内存泄漏和内存回收机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内存泄漏"><span class="nav-number">1.2.</span> <span class="nav-text">内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#垃圾回收机制"><span class="nav-number">1.3.</span> <span class="nav-text">垃圾回收机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#无法访问的数据区域"><span class="nav-number">1.4.</span> <span class="nav-text">无法访问的数据区域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#内部算法"><span class="nav-number">1.5.</span> <span class="nav-text">内部算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-HTML-空元素："><span class="nav-number">2.</span> <span class="nav-text">2. HTML 空元素：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HTML空元素："><span class="nav-number">2.1.</span> <span class="nav-text">HTML空元素：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-HTML-CSS-基础："><span class="nav-number">3.</span> <span class="nav-text">3. HTML-CSS-基础：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-对HTML语义化的理解"><span class="nav-number">3.1.</span> <span class="nav-text">1) 对HTML语义化的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-子元素垂直水平居中的实现方式"><span class="nav-number">3.2.</span> <span class="nav-text">2) 子元素垂直水平居中的实现方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-css选择器-gt-空格-的区别"><span class="nav-number">3.3.</span> <span class="nav-text">3) css选择器 . # &gt; 空格 , + 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-BFC（块格式化上下文-Block-Formatting-Context-）"><span class="nav-number">3.4.</span> <span class="nav-text">4) BFC（块格式化上下文 Block Formatting Context ）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-对H5的理解"><span class="nav-number">3.5.</span> <span class="nav-text">5) 对H5的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-CSS3动画"><span class="nav-number">3.6.</span> <span class="nav-text">6) CSS3动画</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-css-引入方式优先级"><span class="nav-number">3.7.</span> <span class="nav-text">7) css 引入方式优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-rem-和-px"><span class="nav-number">3.8.</span> <span class="nav-text">8) rem 和 px</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-link-和-import的区别"><span class="nav-number">3.9.</span> <span class="nav-text">9)link 和 @import的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-CSS-Reset-的作用和用途"><span class="nav-number">3.10.</span> <span class="nav-text">10) CSS Reset 的作用和用途</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-CSS-Sprites-如何使用和他的优点是什么"><span class="nav-number">3.11.</span> <span class="nav-text">11) CSS Sprites 如何使用和他的优点是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-为何要使用translate-而不是position-absolute，理由是什么"><span class="nav-number">3.12.</span> <span class="nav-text">12) 为何要使用translate()而不是position:absolute，理由是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-CSS处理背景透明度，文字透明与否"><span class="nav-number">3.13.</span> <span class="nav-text">13)  CSS处理背景透明度，文字透明与否</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14-什么是置换元素"><span class="nav-number">3.14.</span> <span class="nav-text">14) 什么是置换元素</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-浅拷贝与深拷贝（一）："><span class="nav-number">4.</span> <span class="nav-text">4. 浅拷贝与深拷贝（一）：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#浅拷贝与深拷贝"><span class="nav-number">4.1.</span> <span class="nav-text">浅拷贝与深拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#赋值和深-浅拷贝的区别"><span class="nav-number">4.2.</span> <span class="nav-text">赋值和深&#x2F;浅拷贝的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#浅拷贝的实现方式"><span class="nav-number">4.3.</span> <span class="nav-text">浅拷贝的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-Object-assign"><span class="nav-number">4.3.1.</span> <span class="nav-text">1) Object.assign()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-函数库lodash的-clone方法"><span class="nav-number">4.3.2.</span> <span class="nav-text">2) 函数库lodash的_.clone方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-展开运算符…"><span class="nav-number">4.3.3.</span> <span class="nav-text">3) 展开运算符…</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-Array-prototype-concat"><span class="nav-number">4.3.4.</span> <span class="nav-text">4) Array.prototype.concat()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-Array-prototype-slice"><span class="nav-number">4.3.5.</span> <span class="nav-text">5) Array.prototype.slice()</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#深拷贝的实现方式"><span class="nav-number">4.4.</span> <span class="nav-text">深拷贝的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-JSON-parse-JSON-stringify"><span class="nav-number">4.4.1.</span> <span class="nav-text">1) JSON.parse(JSON.stringify())</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-函数库lodash的-cloneDeep方法"><span class="nav-number">4.4.2.</span> <span class="nav-text">2) 函数库lodash的_.cloneDeep方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-jQuery-extend-方法"><span class="nav-number">4.4.3.</span> <span class="nav-text">3) jQuery.extend()方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-手写递归方法"><span class="nav-number">4.4.4.</span> <span class="nav-text">4) 手写递归方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-浅拷贝与深拷贝（二）："><span class="nav-number">5.</span> <span class="nav-text">5. 浅拷贝与深拷贝（二）：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#浅拷贝"><span class="nav-number">5.1.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#深拷贝"><span class="nav-number">5.2.</span> <span class="nav-text">深拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一个简单的深拷贝方法"><span class="nav-number">5.3.</span> <span class="nav-text">一个简单的深拷贝方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结："><span class="nav-number">5.4.</span> <span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-ES6数组方法："><span class="nav-number">6.</span> <span class="nav-text">6. ES6数组方法：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-arr-push-从后面添加元素，返回值为添加完后的数组的长度"><span class="nav-number">6.1.</span> <span class="nav-text">(1)  arr.push() 从后面添加元素，返回值为添加完后的数组的长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-arr-pop-从后面删除元素，只能是一个，返回值是删除的元素"><span class="nav-number">6.2.</span> <span class="nav-text">(2)  arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-arr-shift-从前面删除元素，只能删除一个-返回值是删除的元素"><span class="nav-number">6.3.</span> <span class="nav-text">(3)  arr.shift() 从前面删除元素，只能删除一个 返回值是删除的元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-arr-unshift-从前面添加元素-返回值是添加完后的数组的长度"><span class="nav-number">6.4.</span> <span class="nav-text">(4)  arr.unshift() 从前面添加元素, 返回值是添加完后的数组的长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-arr-splice-i-n-删除从i-索引值-开始之后的那个元素。返回值是删除的元素"><span class="nav-number">6.5.</span> <span class="nav-text">(5)  arr.splice(i,n) 删除从i(索引值)开始之后的那个元素。返回值是删除的元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-arr-concat-连接两个数组-返回值为连接后的新数组"><span class="nav-number">6.6.</span> <span class="nav-text">(6) arr.concat() 连接两个数组 返回值为连接后的新数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-str-split-将字符串转化为数组"><span class="nav-number">6.7.</span> <span class="nav-text">(7)  str.split() 将字符串转化为数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-arr-sort-将数组进行排序-返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的，见例子"><span class="nav-number">6.8.</span> <span class="nav-text">(8)  arr.sort() 将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的，见例子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-arr-reverse-将数组反转-返回值是反转后的数组"><span class="nav-number">6.9.</span> <span class="nav-text">(9)  arr.reverse() 将数组反转,返回值是反转后的数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-arr-slice-start-end-切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组"><span class="nav-number">6.10.</span> <span class="nav-text">(10) arr.slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-arr-forEach-callback-遍历数组-无return"><span class="nav-number">6.11.</span> <span class="nav-text">(11)  arr.forEach(callback) 遍历数组,无return</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-arr-map-callback-映射数组-遍历数组-有return-返回一个新数组"><span class="nav-number">6.12.</span> <span class="nav-text">(12)  arr.map(callback) 映射数组(遍历数组),有return 返回一个新数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-arr-filter-callback-过滤数组，返回一个满足要求的数组"><span class="nav-number">6.13.</span> <span class="nav-text">(13)  arr.filter(callback) 过滤数组，返回一个满足要求的数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14-arr-every-callback-依据判断条件，数组的元素是否全满足，若满足则返回ture"><span class="nav-number">6.14.</span> <span class="nav-text">(14) arr.every(callback) 依据判断条件，数组的元素是否全满足，若满足则返回ture</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#15-arr-some-依据判断条件，数组的元素是否有一个满足，若有一个满足则返回ture"><span class="nav-number">6.15.</span> <span class="nav-text">(15)arr.some() 依据判断条件，数组的元素是否有一个满足，若有一个满足则返回ture</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#16-arr-reduce-callback-initialValue-迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值"><span class="nav-number">6.16.</span> <span class="nav-text">(16) arr.reduce(callback, initialValue) 迭代数组的所有项，累加器，数组中的每个值（从左到右）合并，最终计算为一个值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#17-arr-reduceRight-callback-initialValue-与arr-reduce-功能一样，不同的是，reduceRight-从数组的末尾向前将数组中的数组项做累加。"><span class="nav-number">6.17.</span> <span class="nav-text">(17) arr.reduceRight(callback, initialValue) 与arr.reduce()功能一样，不同的是，reduceRight()从数组的末尾向前将数组中的数组项做累加。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-arr-indexOf-查找某个元素的索引值，若有重复的，则返回第一个查到的索引值若不存在，则返回-1"><span class="nav-number">6.18.</span> <span class="nav-text">(18)arr.indexOf() 查找某个元素的索引值，若有重复的，则返回第一个查到的索引值若不存在，则返回 -1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#19-arr-lastIndexOf-和arr-indexOf-的功能一样，不同的是从后往前查找"><span class="nav-number">6.19.</span> <span class="nav-text">(19)arr.lastIndexOf()  和arr.indexOf()的功能一样，不同的是从后往前查找</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#20-Array-from-将伪数组变成数组，就是只要有length的就可以转成数组。-—es6"><span class="nav-number">6.20.</span> <span class="nav-text">(20)Array.from() 将伪数组变成数组，就是只要有length的就可以转成数组。 —es6</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#21-Array-of-将一组值转换成数组，类似于声明数组-—es6"><span class="nav-number">6.21.</span> <span class="nav-text">(21) Array.of()将一组值转换成数组，类似于声明数组  —es6</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#22-arr-copyWithin-在当前数组内部，将制定位置的数组复制到其他位置，会覆盖原数组项，返回当前数组"><span class="nav-number">6.22.</span> <span class="nav-text">(22) arr.copyWithin() 在当前数组内部，将制定位置的数组复制到其他位置，会覆盖原数组项，返回当前数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#23-arr-find-callback-找到第一个符合条件的数组成员"><span class="nav-number">6.23.</span> <span class="nav-text">(23) arr.find(callback) 找到第一个符合条件的数组成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#24-arr-findIndex-callback-找到第一个符合条件的数组成员的索引值"><span class="nav-number">6.24.</span> <span class="nav-text">(24) arr.findIndex(callback) 找到第一个符合条件的数组成员的索引值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#25-arr-fill-target-start-end-使用给定的值，填充一个数组-ps-填充完后会改变原数组"><span class="nav-number">6.25.</span> <span class="nav-text">(25) arr.fill(target, start, end) 使用给定的值，填充一个数组,ps:填充完后会改变原数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#26-arr-includes-判断数中是否包含给定的值"><span class="nav-number">6.26.</span> <span class="nav-text">(26) arr.includes() 判断数中是否包含给定的值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#27-arr-keys-遍历数组的键名"><span class="nav-number">6.27.</span> <span class="nav-text">(27) arr.keys() 遍历数组的键名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#28-arr-values-遍历数组键值"><span class="nav-number">6.28.</span> <span class="nav-text">(28) arr.values() 遍历数组键值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#29-arr-entries-遍历数组的键名和键值"><span class="nav-number">6.29.</span> <span class="nav-text">(29) arr.entries() 遍历数组的键名和键值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-新提案（ES6数组方法）："><span class="nav-number">6.30.</span> <span class="nav-text">6 - 1. 新提案（ES6数组方法）：</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-Array-at"><span class="nav-number">6.30.1.</span> <span class="nav-text">(1) Array.at()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-Array-reduce-callback-initialValue"><span class="nav-number">6.30.2.</span> <span class="nav-text">(2) Array.reduce(callback, [initialValue])</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-JavaScript映射器-Array-flatMap"><span class="nav-number">6.30.3.</span> <span class="nav-text">(3) JavaScript映射器: Array.flatMap()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-JavaScript-新提案：array-groupBy"><span class="nav-number">6.30.4.</span> <span class="nav-text">(4) JavaScript 新提案：array.groupBy()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-findLast"><span class="nav-number">6.30.5.</span> <span class="nav-text">(5) findLast()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-findLastIndex"><span class="nav-number">6.30.6.</span> <span class="nav-text">(6) findLastIndex()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-arr-sort"><span class="nav-number">6.30.7.</span> <span class="nav-text">(7) arr.sort()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-ES6新增语法："><span class="nav-number">7.</span> <span class="nav-text">7. ES6新增语法：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（一）let-和-const"><span class="nav-number">7.1.</span> <span class="nav-text">（一）let 和 const</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-let"><span class="nav-number">7.1.1.</span> <span class="nav-text">1) let</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-const"><span class="nav-number">7.1.2.</span> <span class="nav-text">2) const</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-总结"><span class="nav-number">7.1.3.</span> <span class="nav-text">3) 总结</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（二）解构赋值"><span class="nav-number">7.2.</span> <span class="nav-text">（二）解构赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-数组解构"><span class="nav-number">7.2.1.</span> <span class="nav-text">1) 数组解构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-对象解构"><span class="nav-number">7.2.2.</span> <span class="nav-text">2) 对象解构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（三）函数和参数"><span class="nav-number">7.3.</span> <span class="nav-text">（三）函数和参数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-箭头函数"><span class="nav-number">7.3.1.</span> <span class="nav-text">1) 箭头函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-参数的默认值"><span class="nav-number">7.3.2.</span> <span class="nav-text">2) 参数的默认值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-rest参数"><span class="nav-number">7.3.3.</span> <span class="nav-text">3) rest参数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（四）内置函数的扩展"><span class="nav-number">7.4.</span> <span class="nav-text">（四）内置函数的扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-扩展运算符："><span class="nav-number">7.4.1.</span> <span class="nav-text">1) 扩展运算符：...</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-Array-from"><span class="nav-number">7.4.2.</span> <span class="nav-text">2) Array.from()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-find-方法和-findIndex-方法"><span class="nav-number">7.4.3.</span> <span class="nav-text">3) find() 方法和 findIndex() 方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-includes-方法"><span class="nav-number">7.4.4.</span> <span class="nav-text">4) includes()方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-includes-startsWith-endsWith"><span class="nav-number">7.4.5.</span> <span class="nav-text">5) includes(), startsWith(), endsWith()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-repeat-方法"><span class="nav-number">7.4.6.</span> <span class="nav-text">6) repeat()方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（五）新增对象Set"><span class="nav-number">7.5.</span> <span class="nav-text">（五）新增对象Set</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-flex布局中align-items-和align-content的区别："><span class="nav-number">8.</span> <span class="nav-text">8. flex布局中align-items 和align-content的区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-vue中computed和watch的区别："><span class="nav-number">9.</span> <span class="nav-text">9. vue中computed和watch的区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-关于Vue中computed-和-watch-的区别："><span class="nav-number">10.</span> <span class="nav-text">10. 关于Vue中computed-和-watch-的区别：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-vue中watch-computed-mehtod执行顺序："><span class="nav-number">11.</span> <span class="nav-text">11. vue中watch,computed,mehtod执行顺序：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-Event-Loop（一）"><span class="nav-number">12.</span> <span class="nav-text">12. Event Loop（一）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-Event-Loop（二）"><span class="nav-number">13.</span> <span class="nav-text">13. Event Loop（二）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-vue中对象数组去重"><span class="nav-number">14.</span> <span class="nav-text">14. vue中对象数组去重</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-回顾盒子模型之box-size属性"><span class="nav-number">15.</span> <span class="nav-text">15. 回顾盒子模型之box-size属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-Vue-set-和-this-set-区别"><span class="nav-number">16.</span> <span class="nav-text">16. Vue.set() 和 this.$set() 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-JS对象转换为数组"><span class="nav-number">17.</span> <span class="nav-text">17. JS对象转换为数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一、把类似数组的对象转换成数组"><span class="nav-number">17.1.</span> <span class="nav-text">一、把类似数组的对象转换成数组</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1）什么是类似数组的对象（伪数组）"><span class="nav-number">17.1.1.</span> <span class="nav-text">1）什么是类似数组的对象（伪数组）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2）转换方法"><span class="nav-number">17.1.2.</span> <span class="nav-text">2）转换方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二、延伸-Array-from"><span class="nav-number">17.2.</span> <span class="nav-text">二、延伸 Array.from()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1）作用："><span class="nav-number">17.2.1.</span> <span class="nav-text">1）作用：</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2）实际应用："><span class="nav-number">17.2.2.</span> <span class="nav-text">2）实际应用：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-数组遍历与箭头函数的注意点"><span class="nav-number">18.</span> <span class="nav-text">18. 数组遍历与箭头函数的注意点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-JS-号的行为"><span class="nav-number">19.</span> <span class="nav-text">19. JS + 号的行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-JS-更改对象中的属性名"><span class="nav-number">20.</span> <span class="nav-text">20. JS 更改对象中的属性名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-CSS省略号相关设置（限制n行）"><span class="nav-number">21.</span> <span class="nav-text">21. CSS省略号相关设置（限制n行）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-怎么检查JavaScript对象上是否存在一个属性？"><span class="nav-number">22.</span> <span class="nav-text">22. 怎么检查JavaScript对象上是否存在一个属性？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-真值检查"><span class="nav-number">22.1.</span> <span class="nav-text">(1) 真值检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-in-操作符"><span class="nav-number">22.2.</span> <span class="nav-text">(2) in 操作符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-hasOwnProperty"><span class="nav-number">22.3.</span> <span class="nav-text">(3) hasOwnProperty()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-JS-Symbol-类型"><span class="nav-number">23.</span> <span class="nav-text">23 JS  Symbol 类型 </span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Symbol-类型"><span class="nav-number">23.1.</span> <span class="nav-text">(1) Symbol 类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Symbol-函数不可以-new"><span class="nav-number">23.2.</span> <span class="nav-text">(2) Symbol() 函数不可以 new</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-常用的内置符号-Symbol的工厂函数"><span class="nav-number">23.3.</span> <span class="nav-text">(3) 常用的内置符号 Symbol的工厂函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#①-Symbol-asyncIterator"><span class="nav-number">23.3.1.</span> <span class="nav-text">① Symbol.asyncIterator</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#②-Symbol-hasInstance"><span class="nav-number">23.3.2.</span> <span class="nav-text">② Symbol.hasInstance</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#③-Symbol-isConcatSpreadable"><span class="nav-number">23.3.3.</span> <span class="nav-text">③ Symbol.isConcatSpreadable</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#④-Symbol-iterator"><span class="nav-number">23.3.4.</span> <span class="nav-text">④ Symbol.iterator</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#⑤-Symbol-match-replace-search-species-split"><span class="nav-number">23.3.5.</span> <span class="nav-text">⑤ Symbol.match&#x2F;replace&#x2F;search&#x2F;species&#x2F;split</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#⑥-Symbol-toPrimitive"><span class="nav-number">23.3.6.</span> <span class="nav-text">⑥ Symbol.toPrimitive</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#⑦-Symbol-toStringTag"><span class="nav-number">23.3.7.</span> <span class="nav-text">⑦ Symbol.toStringTag</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#⑧-Symbol-unscopables"><span class="nav-number">23.3.8.</span> <span class="nav-text">⑧ Symbol.unscopables</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-JS实现将文本或JSON内容下载到文件中"><span class="nav-number">24.</span> <span class="nav-text">24. JS实现将文本或JSON内容下载到文件中</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-下载文本"><span class="nav-number">24.1.</span> <span class="nav-text">1) 下载文本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-下载JSON"><span class="nav-number">24.2.</span> <span class="nav-text">2) 下载JSON</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-下载JSON并格式化"><span class="nav-number">24.3.</span> <span class="nav-text">3) 下载JSON并格式化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-JavaScript-继承"><span class="nav-number">25.</span> <span class="nav-text">25. JavaScript 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）-原型链继承"><span class="nav-number">25.1.</span> <span class="nav-text">（1） 原型链继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）借助构造函数继承（经典继承）"><span class="nav-number">25.2.</span> <span class="nav-text">（2）借助构造函数继承（经典继承）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）组合继承：原型链-借用构造函数（最常用）"><span class="nav-number">25.3.</span> <span class="nav-text">（3）组合继承：原型链 + 借用构造函数（最常用）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）原型式继承-（Object-create）"><span class="nav-number">25.4.</span> <span class="nav-text">（4）原型式继承 （Object.create）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（5）寄生式继承"><span class="nav-number">25.5.</span> <span class="nav-text">（5）寄生式继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（6）寄生组合式继承（最理想的）"><span class="nav-number">25.6.</span> <span class="nav-text">（6）寄生组合式继承（最理想的）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（7）-ES6-中class的继承"><span class="nav-number">25.7.</span> <span class="nav-text">（7） ES6 中class的继承</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-JS-中-this-的理解"><span class="nav-number">26.</span> <span class="nav-text">26. JS 中 this 的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）-全局上下文"><span class="nav-number">26.1.</span> <span class="nav-text">（1） 全局上下文</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）-直接调用函数"><span class="nav-number">26.2.</span> <span class="nav-text">（2） 直接调用函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）-对象-方法的形式调用"><span class="nav-number">26.3.</span> <span class="nav-text">（3） 对象.方法的形式调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（4）-DOM事件绑定"><span class="nav-number">26.4.</span> <span class="nav-text">（4） DOM事件绑定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（5）-new-构造函数"><span class="nav-number">26.5.</span> <span class="nav-text">（5） new+构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（6）-箭头函数？"><span class="nav-number">26.6.</span> <span class="nav-text">（6） 箭头函数？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-JS-中-、-、-的用法和含义"><span class="nav-number">27.</span> <span class="nav-text">27. JS 中 ?.、??、??&#x3D; 的用法和含义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）可选链"><span class="nav-number">27.1.</span> <span class="nav-text">（1）可选链(?.)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）空值合并运算符"><span class="nav-number">27.2.</span> <span class="nav-text">（2）空值合并运算符(??)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）空值赋值运算符"><span class="nav-number">27.3.</span> <span class="nav-text">（3）空值赋值运算符(??&#x3D;)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-实现-JS-重载"><span class="nav-number">28.</span> <span class="nav-text">28. 实现 JS 重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-ES6-解构赋值的实用技巧"><span class="nav-number">29.</span> <span class="nav-text">29. ES6 解构赋值的实用技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一、基本概念"><span class="nav-number">29.1.</span> <span class="nav-text">一、基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二、解构分类"><span class="nav-number">29.2.</span> <span class="nav-text">二、解构分类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-对象的解构赋值"><span class="nav-number">29.2.1.</span> <span class="nav-text">1. 对象的解构赋值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-数组的解构赋值"><span class="nav-number">29.2.2.</span> <span class="nav-text">2. 数组的解构赋值</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三、嵌套解构"><span class="nav-number">29.3.</span> <span class="nav-text">三、嵌套解构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#四、使用技巧"><span class="nav-number">29.4.</span> <span class="nav-text">四、使用技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-函数解构"><span class="nav-number">29.4.1.</span> <span class="nav-text">1. 函数解构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-循环中的解构"><span class="nav-number">29.4.2.</span> <span class="nav-text">2. 循环中的解构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-动态属性解构"><span class="nav-number">29.4.3.</span> <span class="nav-text">3. 动态属性解构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-交换变量"><span class="nav-number">29.4.4.</span> <span class="nav-text">4. 交换变量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-数组拷贝"><span class="nav-number">29.4.5.</span> <span class="nav-text">5. 数组拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-CSS实现带箭头的提示框"><span class="nav-number">30.</span> <span class="nav-text">30. CSS实现带箭头的提示框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-8种Vue中数据更新了但页面没有更新的情况"><span class="nav-number">31.</span> <span class="nav-text">31.  8种Vue中数据更新了但页面没有更新的情况</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#①-Vue-无法检测实例被创建时不存在于-data-中的-属性"><span class="nav-number">31.1.</span> <span class="nav-text">①  Vue 无法检测实例被创建时不存在于 data 中的 属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#②-Vue-无法检测‘对象属性’的添加或移除"><span class="nav-number">31.2.</span> <span class="nav-text">② Vue 无法检测‘对象属性’的添加或移除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#③-Vue-不能检测利用数组索引直接修改一个数组项"><span class="nav-number">31.3.</span> <span class="nav-text">③ Vue 不能检测利用数组索引直接修改一个数组项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#④-Vue-不能监测直接修改数组长度的变化"><span class="nav-number">31.4.</span> <span class="nav-text">④ Vue 不能监测直接修改数组长度的变化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#⑤-在异步更新执行之前操作-DOM-数据不会变化"><span class="nav-number">31.5.</span> <span class="nav-text">⑤ 在异步更新执行之前操作 DOM 数据不会变化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#⑥-循环嵌套层级太深，视图不更新"><span class="nav-number">31.6.</span> <span class="nav-text">⑥ 循环嵌套层级太深，视图不更新</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#⑦-路由参数变化时，页面不更新（数据不更新）"><span class="nav-number">31.7.</span> <span class="nav-text">⑦ 路由参数变化时，页面不更新（数据不更新）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#⑧-使用keep-alive之后数据无法实时更新问题"><span class="nav-number">31.8.</span> <span class="nav-text">⑧ 使用keep-alive之后数据无法实时更新问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-ES6-Array-from-详解"><span class="nav-number">32.</span> <span class="nav-text">32. ES6 Array.from() 详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#语法"><span class="nav-number">32.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#参数"><span class="nav-number">32.2.</span> <span class="nav-text">参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#返回值"><span class="nav-number">32.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#描述"><span class="nav-number">32.4.</span> <span class="nav-text">描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#示例"><span class="nav-number">32.5.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-从-String-生成数组"><span class="nav-number">32.5.1.</span> <span class="nav-text">(1) 从 String 生成数组</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-从-Set-生成数组"><span class="nav-number">32.5.2.</span> <span class="nav-text">(2) 从 Set 生成数组</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-从-Map-生成数组"><span class="nav-number">32.5.3.</span> <span class="nav-text">(3) 从 Map 生成数组</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-从类数组对象（arguments）生成数组"><span class="nav-number">32.5.4.</span> <span class="nav-text">(4) 从类数组对象（arguments）生成数组</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-在-Array-from-中使用箭头函数"><span class="nav-number">32.5.5.</span> <span class="nav-text">(5) 在 Array.from 中使用箭头函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-序列生成器-指定范围"><span class="nav-number">32.5.6.</span> <span class="nav-text">(6) 序列生成器 (指定范围)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-数组去重合并"><span class="nav-number">32.5.7.</span> <span class="nav-text">(7) 数组去重合并</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-JS数组转化为对象"><span class="nav-number">33.</span> <span class="nav-text">33. JS数组转化为对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#①-利用Object-fromEntries-与map-方法："><span class="nav-number">33.1.</span> <span class="nav-text">① 利用Object.fromEntries()与map()方法：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#②-利用扩展运算符"><span class="nav-number">33.2.</span> <span class="nav-text">② 利用扩展运算符...</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-CSS设置text从第二行开始缩进："><span class="nav-number">34.</span> <span class="nav-text">34. CSS设置text从第二行开始缩进：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35-CSS-SASS-SCSS-中的变量的使用注意点："><span class="nav-number">35.</span> <span class="nav-text">35. CSS SASS(SCSS)中的变量的使用注意点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#0-共勉："><span class="nav-number">36.</span> <span class="nav-text">0. 共勉：</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">F゛</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/note/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/note/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/note/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/note/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/note/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/note/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/note/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/note/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/note/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/note/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/note/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/note/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/note/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/note/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
</body>
</html>
